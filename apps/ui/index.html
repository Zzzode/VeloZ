<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>VeloZ UI</title>
  <!-- Strategy-specific styles (optional, for enhanced styling) -->
  <link rel="stylesheet" href="css/strategies.css" />
  <!-- Order book styles -->
  <link rel="stylesheet" href="css/orderbook.css" />
  <!-- Position styles -->
  <link rel="stylesheet" href="css/positions.css" />
  <!-- Backtest styles -->
  <link rel="stylesheet" href="css/backtest.css" />
  <style>
    :root {
      --color-bg: #ffffff;
      --color-bg-secondary: #f9fafb;
      --color-border: #e5e7eb;
      --color-border-light: #f1f5f9;
      --color-text: #111827;
      --color-text-muted: #6b7280;
      --color-primary: #111827;
      --color-success: #059669;
      --color-warning: #d97706;
      --color-danger: #dc2626;
      --color-info: #2563eb;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji",
        "Segoe UI Emoji";
      margin: 0;
      padding: 24px;
      background: var(--color-bg);
      color: var(--color-text);
      line-height: 1.5;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }

    .card {
      border: 1px solid var(--color-border);
      border-radius: 10px;
      padding: 16px;
      margin-top: 14px;
      background: var(--color-bg);
    }

    .card-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .card-header h2 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }

    input,
    select,
    button,
    textarea {
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid #d1d5db;
      font-size: 14px;
      font-family: inherit;
    }

    textarea {
      resize: vertical;
      min-height: 80px;
    }

    button {
      background: var(--color-primary);
      color: white;
      border: 0;
      cursor: pointer;
      transition: opacity 0.15s;
    }

    button:hover:not(:disabled) {
      opacity: 0.9;
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
    }

    button.btn-success {
      background: var(--color-success);
    }

    button.btn-danger {
      background: var(--color-danger);
    }

    button.btn-warning {
      background: var(--color-warning);
    }

    button.btn-secondary {
      background: var(--color-bg-secondary);
      color: var(--color-text);
      border: 1px solid var(--color-border);
    }

    button.btn-sm {
      padding: 6px 10px;
      font-size: 12px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th,
    td {
      border-bottom: 1px solid var(--color-border-light);
      padding: 8px 6px;
      text-align: left;
      font-size: 13px;
    }

    th {
      font-weight: 600;
      color: var(--color-text-muted);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .muted {
      color: var(--color-text-muted);
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    /* Navigation Tabs */
    .nav-tabs {
      display: flex;
      gap: 4px;
      border-bottom: 1px solid var(--color-border);
      margin-bottom: 20px;
      padding-bottom: 0;
    }

    .nav-tab {
      padding: 12px 20px;
      background: none;
      border: none;
      border-bottom: 2px solid transparent;
      color: var(--color-text-muted);
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.15s;
      margin-bottom: -1px;
    }

    .nav-tab:hover {
      color: var(--color-text);
    }

    .nav-tab.active {
      color: var(--color-text);
      border-bottom-color: var(--color-primary);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* Status Badges */
    .badge {
      display: inline-flex;
      align-items: center;
      padding: 4px 10px;
      border-radius: 9999px;
      font-size: 12px;
      font-weight: 500;
      gap: 6px;
    }

    .badge-running {
      background: #d1fae5;
      color: #065f46;
    }

    .badge-stopped {
      background: #fee2e2;
      color: #991b1b;
    }

    .badge-paused {
      background: #fef3c7;
      color: #92400e;
    }

    .badge-error {
      background: #fee2e2;
      color: #991b1b;
    }

    .badge::before {
      content: "";
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: currentColor;
    }

    /* Strategy Cards */
    .strategy-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
      gap: 16px;
      margin-top: 16px;
    }

    .strategy-card {
      border: 1px solid var(--color-border);
      border-radius: 10px;
      padding: 16px;
      background: var(--color-bg);
      transition: box-shadow 0.15s;
    }

    .strategy-card:hover {
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    }

    .strategy-card-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 12px;
    }

    .strategy-name {
      font-weight: 600;
      font-size: 16px;
      margin: 0 0 4px 0;
    }

    .strategy-type {
      font-size: 12px;
      color: var(--color-text-muted);
    }

    .strategy-metrics {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      margin: 16px 0;
      padding: 12px;
      background: var(--color-bg-secondary);
      border-radius: 8px;
    }

    .metric-item {
      display: flex;
      flex-direction: column;
    }

    .metric-label {
      font-size: 11px;
      color: var(--color-text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .metric-value {
      font-size: 16px;
      font-weight: 600;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    }

    .metric-value.positive {
      color: var(--color-success);
    }

    .metric-value.negative {
      color: var(--color-danger);
    }

    .strategy-actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }

    .strategy-actions button {
      flex: 1;
    }

    /* Parameter Form */
    .param-form {
      display: grid;
      gap: 16px;
    }

    .param-group {
      display: grid;
      gap: 6px;
    }

    .param-label {
      font-size: 13px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .param-label .hot-badge {
      font-size: 10px;
      padding: 2px 6px;
      background: #dbeafe;
      color: #1d4ed8;
      border-radius: 4px;
    }

    .param-input {
      width: 100%;
    }

    .param-hint {
      font-size: 12px;
      color: var(--color-text-muted);
    }

    /* Trade History */
    .trade-row {
      display: flex;
      align-items: center;
      padding: 10px 0;
      border-bottom: 1px solid var(--color-border-light);
      gap: 12px;
    }

    .trade-row:last-child {
      border-bottom: none;
    }

    .trade-side {
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .trade-side.buy {
      background: #d1fae5;
      color: #065f46;
    }

    .trade-side.sell {
      background: #fee2e2;
      color: #991b1b;
    }

    .trade-info {
      flex: 1;
    }

    .trade-symbol {
      font-weight: 500;
    }

    .trade-details {
      font-size: 12px;
      color: var(--color-text-muted);
    }

    .trade-pnl {
      font-weight: 600;
      font-family: ui-monospace, monospace;
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s;
    }

    .modal-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .modal {
      background: var(--color-bg);
      border-radius: 12px;
      padding: 24px;
      max-width: 500px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      transform: scale(0.95);
      transition: transform 0.2s;
    }

    .modal-overlay.active .modal {
      transform: scale(1);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .modal-header h3 {
      margin: 0;
      font-size: 18px;
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: var(--color-text-muted);
      padding: 0;
      line-height: 1;
    }

    .modal-footer {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 24px;
    }

    /* Live indicator */
    .live-indicator {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--color-success);
    }

    .live-indicator::before {
      content: "";
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--color-success);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Flex utilities */
    .flex-1 {
      flex: 1;
    }

    .gap-8 {
      gap: 8px;
    }

    .mt-12 {
      margin-top: 12px;
    }

    .mb-12 {
      margin-bottom: 12px;
    }

    /* Responsive */
    @media (max-width: 768px) {
      body {
        padding: 16px;
      }

      .strategy-grid {
        grid-template-columns: 1fr;
      }

      .nav-tabs {
        overflow-x: auto;
      }

      .nav-tab {
        white-space: nowrap;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>VeloZ</h1>
    <div class="muted mb-12">Quantitative Trading Framework</div>

    <!-- Navigation Tabs -->
    <div class="nav-tabs">
      <button class="nav-tab active" data-tab="trading">Trading</button>
      <button class="nav-tab" data-tab="orderbook">Order Book</button>
      <button class="nav-tab" data-tab="positions">Positions</button>
      <button class="nav-tab" data-tab="strategies">Strategies</button>
      <button class="nav-tab" data-tab="backtest">Backtest</button>
    </div>

    <!-- Trading Tab -->
    <div id="trading-tab" class="tab-content active">
      <div class="card">
        <div class="row">
          <div>
            <div class="muted">API Base</div>
            <input id="apiBase" style="min-width: 320px" placeholder="e.g. http://127.0.0.1:8080" />
          </div>
          <div>
            <div class="muted">Connection</div>
            <div class="mono" id="conn">-</div>
          </div>
          <div>
            <div class="muted">Transport</div>
            <div class="mono" id="transport">-</div>
          </div>
          <div>
            <div class="muted">Execution</div>
            <div class="mono" id="execMode">-</div>
          </div>
          <div>
            <div class="muted">User Stream</div>
            <div class="mono" id="userStream">-</div>
          </div>
          <div style="flex: 1"></div>
          <button id="execPing">Ping</button>
          <button id="saveApi">Apply</button>
        </div>
        <div id="lastError" class="muted" style="margin-top: 10px"></div>
      </div>

      <div class="card">
        <div class="row">
          <div>
            <div class="muted">Symbol</div>
            <div class="mono" id="symbol">-</div>
          </div>
          <div>
            <div class="muted">Source</div>
            <div class="mono" id="marketSource">-</div>
          </div>
          <div>
            <div class="muted">Price</div>
            <div class="mono" id="price">-</div>
          </div>
          <div>
            <div class="muted">ts_ns</div>
            <div class="mono" id="ts">-</div>
          </div>
          <div style="flex: 1"></div>
          <button id="refresh">Refresh</button>
        </div>
      </div>

      <div class="card">
        <h2 style="margin-top: 0">Place Order</h2>
        <div class="row">
          <select id="side">
            <option value="BUY">BUY</option>
            <option value="SELL">SELL</option>
          </select>
          <input id="orderSymbol" value="BTCUSDT" placeholder="symbol" />
          <input id="qty" value="0.001" placeholder="qty" />
          <input id="orderPrice" value="42000" placeholder="price" />
          <input id="clientId" value="" placeholder="client_order_id (optional)" />
          <button id="submit">Submit</button>
        </div>
        <div id="submitResult" class="muted" style="margin-top: 10px"></div>
      </div>

      <div class="card">
        <h2 style="margin-top: 0">Cancel Order</h2>
        <div class="row">
          <input id="cancelClientId" value="" placeholder="client_order_id" />
          <button id="cancel">Cancel</button>
        </div>
        <div id="cancelResult" class="muted" style="margin-top: 10px"></div>
      </div>

      <div class="card">
        <div class="row">
          <h2 style="margin: 0">Account</h2>
          <div style="flex: 1"></div>
          <button id="reloadAccount">Refresh</button>
        </div>
        <div class="muted" style="margin-top: 6px">Shows /api/account (from user stream in Binance mode)</div>
        <div style="overflow: auto; margin-top: 10px">
          <table>
            <thead>
              <tr>
                <th>asset</th>
                <th>free</th>
                <th>locked</th>
              </tr>
            </thead>
            <tbody id="accountBody"></tbody>
          </table>
        </div>
      </div>

      <div class="card">
        <div class="row">
          <h2 style="margin: 0">Order State</h2>
          <div style="flex: 1"></div>
          <button id="reloadState">Refresh</button>
        </div>
        <div class="muted" style="margin-top: 6px">Shows merged order state view from /api/orders_state</div>
        <div style="overflow: auto; margin-top: 10px">
          <table>
            <thead>
              <tr>
                <th>client_order_id</th>
                <th>status</th>
                <th>symbol</th>
                <th>side</th>
                <th>order_qty</th>
                <th>executed_qty</th>
                <th>avg_price</th>
                <th>venue_order_id</th>
                <th>reason</th>
              </tr>
            </thead>
            <tbody id="stateBody"></tbody>
          </table>
        </div>
      </div>

      <div class="card">
        <div class="row">
          <h2 style="margin: 0">Events</h2>
          <div style="flex: 1"></div>
          <button id="reloadOrders">Refresh</button>
        </div>
        <div class="muted" style="margin-top: 6px">Shows recent events from /api/orders (order_update/fill/error)</div>
        <div style="overflow: auto; margin-top: 10px">
          <table>
            <thead>
              <tr>
                <th>type</th>
                <th>ts_ns</th>
                <th>client_order_id</th>
                <th>status</th>
                <th>symbol</th>
                <th>qty</th>
                <th>price</th>
                <th>reason</th>
              </tr>
            </thead>
            <tbody id="ordersBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- Order Book Tab -->
    <div id="orderbook-tab" class="tab-content">
      <div class="card">
        <div class="card-header">
          <h2>Order Book</h2>
          <div class="flex-1"></div>
          <div class="orderbook-status">
            <span class="status-dot" id="orderbookStatusDot"></span>
            <span id="orderbookStatusText">Disconnected</span>
          </div>
          <select id="orderbookSymbol" style="min-width: 120px;">
            <option value="BTCUSDT">BTCUSDT</option>
            <option value="ETHUSDT">ETHUSDT</option>
            <option value="BNBUSDT">BNBUSDT</option>
          </select>
          <button id="refreshOrderbook" class="btn-secondary btn-sm">Refresh</button>
        </div>
        <div class="muted">Real-time order book depth visualization</div>
      </div>

      <div class="row" style="margin-top: 16px; gap: 16px; align-items: flex-start;">
        <!-- Order Book Widget -->
        <div class="card" style="flex: 1; min-width: 350px;">
          <div class="orderbook-widget" id="orderbookWidget">
            <div class="orderbook-header">
              <div class="orderbook-symbol" id="obSymbol">-</div>
              <div class="orderbook-stats">
                <span class="stat-item">
                  <span class="stat-label">Spread</span>
                  <span class="stat-value" id="obSpread">-</span>
                </span>
                <span class="stat-item">
                  <span class="stat-label">Mid</span>
                  <span class="stat-value" id="obMidPrice">-</span>
                </span>
              </div>
            </div>
            <div class="orderbook-container">
              <div class="orderbook-column-headers">
                <span>Price</span>
                <span>Size</span>
                <span>Total</span>
              </div>
              <div class="orderbook-asks" id="orderbookAsks">
                <div class="orderbook-empty">Waiting for data...</div>
              </div>
              <div class="orderbook-spread">
                <span class="spread-label">Spread</span>
                <span class="spread-value" id="obSpreadValue">-</span>
              </div>
              <div class="orderbook-bids" id="orderbookBids">
                <div class="orderbook-empty">Waiting for data...</div>
              </div>
            </div>
            <div class="orderbook-controls">
              <div class="orderbook-status">
                <span>Last update: <span id="obLastUpdate">-</span></span>
              </div>
              <select id="orderbookGrouping" class="grouping-select">
                <option value="0">No grouping</option>
                <option value="0.01">0.01</option>
                <option value="0.1">0.1</option>
                <option value="1">1</option>
                <option value="10">10</option>
                <option value="100">100</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Order Book Stats -->
        <div class="card" style="flex: 1; min-width: 300px;">
          <div class="card-header">
            <h2>Market Stats</h2>
          </div>
          <div class="row" style="margin-top: 12px; flex-wrap: wrap;">
            <div style="flex: 1; min-width: 120px; margin-bottom: 12px;">
              <div class="muted">Best Bid</div>
              <div class="mono metric-value positive" id="obBestBid">-</div>
            </div>
            <div style="flex: 1; min-width: 120px; margin-bottom: 12px;">
              <div class="muted">Best Ask</div>
              <div class="mono metric-value negative" id="obBestAsk">-</div>
            </div>
            <div style="flex: 1; min-width: 120px; margin-bottom: 12px;">
              <div class="muted">Spread</div>
              <div class="mono metric-value" id="obSpreadAbs">-</div>
            </div>
            <div style="flex: 1; min-width: 120px; margin-bottom: 12px;">
              <div class="muted">Spread %</div>
              <div class="mono metric-value" id="obSpreadPct">-</div>
            </div>
            <div style="flex: 1; min-width: 120px; margin-bottom: 12px;">
              <div class="muted">Bid Depth</div>
              <div class="mono metric-value" id="obBidDepth">-</div>
            </div>
            <div style="flex: 1; min-width: 120px; margin-bottom: 12px;">
              <div class="muted">Ask Depth</div>
              <div class="mono metric-value" id="obAskDepth">-</div>
            </div>
          </div>

          <div class="card-header" style="margin-top: 16px; border-top: 1px solid var(--color-border); padding-top: 16px;">
            <h2>Imbalance</h2>
          </div>
          <div style="margin-top: 12px;">
            <div class="muted">Bid/Ask Ratio</div>
            <div style="display: flex; align-items: center; gap: 8px; margin-top: 8px;">
              <div style="flex: 1; height: 24px; background: var(--color-bg-secondary); border-radius: 4px; overflow: hidden; display: flex;">
                <div id="obImbalanceBar" style="height: 100%; background: var(--color-success); width: 50%; transition: width 0.3s;"></div>
              </div>
              <span class="mono" id="obImbalanceValue">50%</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Positions Tab -->
    <div id="positions-tab" class="tab-content">
      <!-- PnL Summary -->
      <div class="card">
        <div class="card-header">
          <h2>Portfolio Summary</h2>
          <div class="flex-1"></div>
          <div class="position-status">
            <span class="status-dot" id="positionStatusDot"></span>
            <span id="positionStatusText">Disconnected</span>
          </div>
          <button id="refreshPositions" class="btn-secondary btn-sm">Refresh</button>
        </div>
        <div class="muted">Real-time position and PnL tracking</div>

        <!-- PnL Summary Cards -->
        <div class="row" style="margin-top: 16px; gap: 16px; flex-wrap: wrap;">
          <div class="pnl-card" style="flex: 1; min-width: 200px;">
            <div class="pnl-card-title">Total PnL</div>
            <div class="pnl-card-value" id="posTotalPnl">$0.00</div>
            <div class="pnl-card-change" id="posTotalPnlChange">+0.00%</div>
          </div>
          <div class="pnl-card" style="flex: 1; min-width: 200px;">
            <div class="pnl-card-title">Unrealized PnL</div>
            <div class="pnl-card-value" id="posUnrealizedPnl">$0.00</div>
          </div>
          <div class="pnl-card" style="flex: 1; min-width: 200px;">
            <div class="pnl-card-title">Realized PnL</div>
            <div class="pnl-card-value" id="posRealizedPnl">$0.00</div>
          </div>
          <div class="pnl-card" style="flex: 1; min-width: 200px;">
            <div class="pnl-card-title">Total Notional</div>
            <div class="pnl-card-value" id="posTotalNotional">$0.00</div>
          </div>
        </div>
      </div>

      <!-- Positions Table -->
      <div class="card">
        <div class="card-header">
          <h2>Open Positions</h2>
          <div class="flex-1"></div>
          <span class="muted" id="positionCount">0 positions</span>
        </div>
        <div class="positions-table-wrapper" style="margin-top: 12px;">
          <table class="positions-table">
            <thead>
              <tr>
                <th>Symbol</th>
                <th>Side</th>
                <th>Size</th>
                <th>Avg Price</th>
                <th>Current</th>
                <th>Unrealized</th>
                <th>Realized</th>
                <th>Total PnL</th>
                <th>PnL %</th>
              </tr>
            </thead>
            <tbody id="positionsBody">
              <tr>
                <td colspan="9" class="positions-empty" style="text-align: center; padding: 40px;">
                  No open positions
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="positions-last-update">
          Last update: <span id="posLastUpdate">-</span>
        </div>
      </div>

      <!-- PnL History Chart Placeholder -->
      <div class="card">
        <div class="card-header">
          <h2>PnL History</h2>
          <div class="flex-1"></div>
          <select id="pnlHistoryRange">
            <option value="1h">1 Hour</option>
            <option value="4h">4 Hours</option>
            <option value="1d" selected>1 Day</option>
            <option value="1w">1 Week</option>
          </select>
        </div>
        <div class="pnl-chart-container" id="pnlChartContainer">
          Chart will be displayed here when data is available
        </div>
      </div>
    </div>

    <!-- Strategies Tab -->
    <div id="strategies-tab" class="tab-content">
      <!-- Strategy Overview -->
      <div class="card">
        <div class="card-header">
          <h2>Strategy Management</h2>
          <div class="flex-1"></div>
          <span class="live-indicator">Live</span>
          <button id="addStrategy" class="btn-success">+ New Strategy</button>
        </div>
        <div class="muted">Manage and monitor your trading strategies in real-time</div>

        <!-- Strategy List -->
        <div class="strategy-grid" id="strategyGrid">
          <!-- Strategy cards will be rendered here -->
        </div>
      </div>

      <!-- Strategy Performance Summary -->
      <div class="card">
        <div class="card-header">
          <h2>Performance Summary</h2>
          <div class="flex-1"></div>
          <button id="refreshPerformance" class="btn-secondary btn-sm">Refresh</button>
        </div>
        <div class="row" style="margin-top: 12px;">
          <div style="flex: 1; min-width: 150px;">
            <div class="muted">Total PnL</div>
            <div class="mono metric-value" id="totalPnl">-</div>
          </div>
          <div style="flex: 1; min-width: 150px;">
            <div class="muted">Win Rate</div>
            <div class="mono metric-value" id="winRate">-</div>
          </div>
          <div style="flex: 1; min-width: 150px;">
            <div class="muted">Total Trades</div>
            <div class="mono metric-value" id="totalTrades">-</div>
          </div>
          <div style="flex: 1; min-width: 150px;">
            <div class="muted">Active Strategies</div>
            <div class="mono metric-value" id="activeStrategies">-</div>
          </div>
          <div style="flex: 1; min-width: 150px;">
            <div class="muted">Sharpe Ratio</div>
            <div class="mono metric-value" id="sharpeRatio">-</div>
          </div>
        </div>
      </div>

      <!-- Strategy Trade History -->
      <div class="card">
        <div class="card-header">
          <h2>Strategy Trade History</h2>
          <div class="flex-1"></div>
          <select id="tradeHistoryFilter" style="min-width: 150px;">
            <option value="all">All Strategies</option>
          </select>
          <button id="refreshTradeHistory" class="btn-secondary btn-sm">Refresh</button>
        </div>
        <div id="tradeHistoryContainer">
          <!-- Trade history will be rendered here -->
        </div>
      </div>

      <!-- Strategy Metrics Table -->
      <div class="card">
        <div class="card-header">
          <h2>Strategy Metrics</h2>
          <div class="flex-1"></div>
          <button id="refreshMetrics" class="btn-secondary btn-sm">Refresh</button>
        </div>
        <div style="overflow: auto; margin-top: 10px">
          <table>
            <thead>
              <tr>
                <th>Strategy</th>
                <th>Status</th>
                <th>PnL</th>
                <th>Trades</th>
                <th>Win Rate</th>
                <th>Max DD</th>
                <th>Sharpe</th>
                <th>Uptime</th>
              </tr>
            </thead>
            <tbody id="metricsBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- Backtest Tab -->
    <div id="backtest-tab" class="tab-content">
      <!-- Backtest Controls -->
      <div class="card">
        <div class="card-header">
          <h2>Backtest Results</h2>
          <div class="flex-1"></div>
          <span class="live-indicator">Historical</span>
          <button id="runBacktest" class="btn-success">+ Run Backtest</button>
          <button id="refreshBacktests" class="btn-secondary btn-sm">Refresh</button>
        </div>
        <div class="muted">View and compare historical backtest results</div>

        <!-- Backtest Tabs -->
        <div class="backtest-tabs">
          <button class="backtest-tab active" data-backtest-view="results">Results</button>
          <button class="backtest-tab" data-backtest-view="metrics">Metrics</button>
          <button class="backtest-tab" data-backtest-view="trades">Trades</button>
          <button class="backtest-tab" data-backtest-view="compare">Compare</button>
        </div>

        <!-- Results View -->
        <div id="backtestResultsView" class="backtest-view">
          <div class="backtest-results-list" id="backtestResultsList">
            <!-- Backtest result cards will be rendered here -->
          </div>
        </div>

        <!-- Metrics View -->
        <div id="backtestMetricsView" class="backtest-view" style="display: none;">
          <div class="metrics-panel" id="backtestMetricsPanel">
            <div class="metrics-panel-empty">Select a backtest result to view detailed metrics</div>
          </div>
        </div>

        <!-- Trades View -->
        <div id="backtestTradesView" class="backtest-view" style="display: none;">
          <div class="trades-table-container" id="backtestTradesContainer">
            <div class="trades-empty">Select a backtest result to view trade history</div>
          </div>
        </div>

        <!-- Compare View -->
        <div id="backtestCompareView" class="backtest-view" style="display: none;">
          <div class="comparison-table-container" id="backtestCompareContainer">
            <div class="comparison-empty">Select multiple backtest results to compare</div>
          </div>
        </div>
      </div>

      <!-- Equity Curve Chart -->
      <div class="card">
        <div class="card-header">
          <h2>Equity Curve</h2>
          <div class="flex-1"></div>
          <select id="equityCurveSelect">
            <option value="">Select a backtest...</option>
          </select>
        </div>
        <div class="chart-container" id="equityCurveChart">
          <div class="chart-placeholder">Select a backtest result to view equity curve</div>
        </div>
      </div>

      <!-- Drawdown Chart -->
      <div class="card">
        <div class="card-header">
          <h2>Drawdown Analysis</h2>
          <div class="flex-1"></div>
        </div>
        <div class="chart-container" id="drawdownChart">
          <div class="chart-placeholder">Select a backtest result to view drawdown analysis</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Strategy Parameter Modal -->
  <div class="modal-overlay" id="strategyModal">
    <div class="modal">
      <div class="modal-header">
        <h3 id="modalTitle">Edit Strategy Parameters</h3>
        <button class="modal-close" id="closeModal">&times;</button>
      </div>
      <div id="modalContent">
        <!-- Dynamic content will be inserted here -->
      </div>
      <div class="modal-footer">
        <button class="btn-secondary" id="cancelModal">Cancel</button>
        <button class="btn-success" id="saveModal">Save Changes</button>
      </div>
    </div>
  </div>

  <!-- New Strategy Modal -->
  <div class="modal-overlay" id="newStrategyModal">
    <div class="modal">
      <div class="modal-header">
        <h3>Create New Strategy</h3>
        <button class="modal-close" id="closeNewModal">&times;</button>
      </div>
      <div class="param-form">
        <div class="param-group">
          <label class="param-label">Strategy Name</label>
          <input type="text" id="newStrategyName" class="param-input" placeholder="e.g., BTC Momentum" />
        </div>
        <div class="param-group">
          <label class="param-label">Strategy Type</label>
          <select id="newStrategyType" class="param-input">
            <option value="momentum">Momentum</option>
            <option value="mean_reversion">Mean Reversion</option>
            <option value="grid">Grid Trading</option>
            <option value="arbitrage">Arbitrage</option>
            <option value="market_making">Market Making</option>
            <option value="custom">Custom</option>
          </select>
        </div>
        <div class="param-group">
          <label class="param-label">Symbol</label>
          <input type="text" id="newStrategySymbol" class="param-input" value="BTCUSDT" />
        </div>
        <div class="param-group">
          <label class="param-label">Initial Capital</label>
          <input type="number" id="newStrategyCapital" class="param-input" value="10000" step="100" />
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn-secondary" id="cancelNewModal">Cancel</button>
        <button class="btn-success" id="createStrategy">Create Strategy</button>
      </div>
    </div>
  </div>

  <script>
    // ============================================================================
    // Core API and Connection Management
    // ============================================================================
    const defaultApiBase = (() => {
      const url = new URL(window.location.href);
      const fromQuery = url.searchParams.get("api");
      if (fromQuery) return fromQuery.replace(/\/$/, "");
      if (url.protocol === "file:") return "http://127.0.0.1:8080";
      return "";
    })();

    let apiBase = defaultApiBase;

    function setConn(ok, msg) {
      const el = document.getElementById("conn");
      el.textContent = ok ? "connected" : "disconnected";
      el.style.color = ok ? "#059669" : "#dc2626";
      document.getElementById("lastError").textContent = msg || "";
    }

    async function fetchJson(path) {
      const res = await fetch(apiBase + path, { cache: "no-store" });
      if (!res.ok) throw new Error("http " + res.status);
      return await res.json();
    }

    function setText(id, v) {
      const el = document.getElementById(id);
      if (el) el.textContent = v == null ? "-" : String(v);
    }

    // ============================================================================
    // Tab Navigation
    // ============================================================================
    document.querySelectorAll(".nav-tab").forEach(tab => {
      tab.addEventListener("click", () => {
        document.querySelectorAll(".nav-tab").forEach(t => t.classList.remove("active"));
        document.querySelectorAll(".tab-content").forEach(c => c.classList.remove("active"));
        tab.classList.add("active");
        document.getElementById(tab.dataset.tab + "-tab").classList.add("active");
      });
    });

    // ============================================================================
    // Trading Tab Functions (Original)
    // ============================================================================
    async function refreshMarket() {
      try {
        const m = await fetchJson("/api/market");
        setText("symbol", m.symbol);
        setText("price", m.price);
        setText("ts", m.ts_ns);
        setConn(true, "");
      } catch (e) {
        setConn(false, String(e && e.message ? e.message : e));
      }
    }

    async function refreshConfig() {
      try {
        const c = await fetchJson("/api/config");
        setText("marketSource", c.market_source || "-");
        if (c.market_symbol) setText("symbol", c.market_symbol);
        setText("execMode", c.execution_mode || "-");
        setText("userStream", c.binance_user_stream_connected ? "connected" : "disconnected");
      } catch { }
    }

    function renderOrders(items) {
      const body = document.getElementById("ordersBody");
      body.innerHTML = "";
      for (const e of items.slice().reverse()) {
        const tr = document.createElement("tr");
        const fields = [
          e.type,
          e.ts_ns,
          e.client_order_id,
          e.status,
          e.symbol,
          e.qty,
          e.price,
          e.reason,
        ];
        for (const f of fields) {
          const td = document.createElement("td");
          td.textContent = f == null ? "" : String(f);
          td.className = "mono";
          tr.appendChild(td);
        }
        body.appendChild(tr);
      }
    }

    async function refreshOrders() {
      try {
        const r = await fetchJson("/api/orders");
        renderOrders(r.items || []);
        setConn(true, "");
      } catch (e) {
        setConn(false, String(e && e.message ? e.message : e));
      }
    }

    function renderAccount(items) {
      const body = document.getElementById("accountBody");
      body.innerHTML = "";
      const sorted = (items || []).slice().sort((a, b) => (a.asset || "").localeCompare(b.asset || ""));
      for (const b of sorted) {
        const tr = document.createElement("tr");
        for (const f of [b.asset, b.free, b.locked]) {
          const td = document.createElement("td");
          td.textContent = f == null ? "" : String(f);
          td.className = "mono";
          tr.appendChild(td);
        }
        body.appendChild(tr);
      }
    }

    async function refreshAccount() {
      try {
        const r = await fetchJson("/api/account");
        renderAccount(r.balances || []);
      } catch { }
    }

    function renderState(items) {
      const body = document.getElementById("stateBody");
      body.innerHTML = "";
      const sorted = (items || []).slice().sort((a, b) => {
        const ta = a.last_ts_ns || 0;
        const tb = b.last_ts_ns || 0;
        return tb - ta;
      });
      for (const s of sorted) {
        const tr = document.createElement("tr");
        const fields = [
          s.client_order_id,
          s.status,
          s.symbol,
          s.side,
          s.order_qty,
          s.executed_qty,
          s.avg_price,
          s.venue_order_id,
          s.reason,
        ];
        for (const f of fields) {
          const td = document.createElement("td");
          td.textContent = f == null ? "" : String(f);
          td.className = "mono";
          tr.appendChild(td);
        }
        body.appendChild(tr);
      }
    }

    async function refreshState() {
      try {
        const r = await fetchJson("/api/orders_state");
        renderState(r.items || []);
      } catch { }
    }

    function attachSse() {
      const transport = document.getElementById("transport");
      transport.textContent = "sse";

      if (!("EventSource" in window)) {
        transport.textContent = "poll";
        return null;
      }

      let lastId = localStorage.getItem("veloz_last_id");
      const url = apiBase + "/api/stream" + (lastId ? `?last_id=${encodeURIComponent(lastId)}` : "");
      const es = new EventSource(url);

      es.onopen = () => {
        setConn(true, "");
      };

      es.onerror = () => {
        setConn(false, "sse_error");
      };

      es.addEventListener("market", (ev) => {
        try {
          const m = JSON.parse(ev.data);
          setText("symbol", m.symbol);
          setText("price", m.price);
          setText("ts", m.ts_ns);
          // Update strategy metrics with new market data
          updateStrategyMetricsFromMarket(m);
        } catch { }
        if (ev.lastEventId) localStorage.setItem("veloz_last_id", ev.lastEventId);
      });

      es.addEventListener("order_update", (ev) => {
        if (ev.lastEventId) localStorage.setItem("veloz_last_id", ev.lastEventId);
        refreshOrders().catch(() => { });
        refreshState().catch(() => { });
        // Update strategy trade history
        try {
          const data = JSON.parse(ev.data);
          addStrategyTrade(data);
        } catch { }
      });

      es.addEventListener("fill", (ev) => {
        if (ev.lastEventId) localStorage.setItem("veloz_last_id", ev.lastEventId);
        refreshOrders().catch(() => { });
        refreshState().catch(() => { });
        // Update strategy trade history
        try {
          const data = JSON.parse(ev.data);
          addStrategyTrade(data);
        } catch { }
      });

      es.addEventListener("account", (ev) => {
        if (ev.lastEventId) localStorage.setItem("veloz_last_id", ev.lastEventId);
        refreshAccount().catch(() => { });
      });

      es.addEventListener("error", (ev) => {
        if (ev && ev.data) setConn(false, ev.data);
        if (ev.lastEventId) localStorage.setItem("veloz_last_id", ev.lastEventId);
      });

      // Strategy-specific events
      es.addEventListener("strategy_update", (ev) => {
        try {
          const data = JSON.parse(ev.data);
          updateStrategyFromEvent(data);
        } catch { }
        if (ev.lastEventId) localStorage.setItem("veloz_last_id", ev.lastEventId);
      });

      return es;
    }

    async function submitOrder() {
      const side = document.getElementById("side").value;
      const symbol = document.getElementById("orderSymbol").value.trim();
      const qty = parseFloat(document.getElementById("qty").value);
      const price = parseFloat(document.getElementById("orderPrice").value);
      const clientId = document.getElementById("clientId").value.trim();

      const payload = {
        side,
        symbol,
        qty,
        price,
      };
      if (clientId) payload.client_order_id = clientId;

      const btn = document.getElementById("submit");
      const out = document.getElementById("submitResult");
      btn.disabled = true;
      out.textContent = "Submitting...";
      try {
        const res = await fetch(apiBase + "/api/order", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        const json = await res.json().catch(() => ({}));
        if (!res.ok) {
          out.textContent = "Failed: " + (json.error || "http " + res.status);
          setConn(false, out.textContent);
          return;
        }
        out.textContent = "Success: " + JSON.stringify(json);
        setConn(true, "");
        await new Promise((r) => setTimeout(r, 250));
        await refreshOrders();
      } finally {
        btn.disabled = false;
      }
    }

    async function execPing() {
      const out = document.getElementById("lastError");
      out.textContent = "ping...";
      try {
        const r = await fetchJson("/api/execution/ping");
        out.textContent = JSON.stringify(r);
      } catch (e) {
        out.textContent = String(e && e.message ? e.message : e);
      }
    }

    async function cancelOrder() {
      const client_order_id = document.getElementById("cancelClientId").value.trim();
      const btn = document.getElementById("cancel");
      const out = document.getElementById("cancelResult");
      if (!client_order_id) {
        out.textContent = "Please enter client_order_id";
        return;
      }
      btn.disabled = true;
      out.textContent = "Submitting...";
      try {
        const res = await fetch(apiBase + "/api/cancel", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ client_order_id }),
        });
        const json = await res.json().catch(() => ({}));
        if (!res.ok) {
          out.textContent = "Failed: " + (json.error || "http " + res.status);
          setConn(false, out.textContent);
          return;
        }
        out.textContent = "Success: client_order_id=" + json.client_order_id;
        setConn(true, "");
        await new Promise((r) => setTimeout(r, 200));
        await refreshOrders();
      } finally {
        btn.disabled = false;
      }
    }

    // ============================================================================
    // Strategy Management
    // ============================================================================

    // Strategy data store (simulated - will be replaced with API calls)
    let strategies = [
      {
        id: "strat-001",
        name: "BTC Momentum",
        type: "momentum",
        symbol: "BTCUSDT",
        status: "running",
        capital: 10000,
        pnl: 523.45,
        pnlPercent: 5.23,
        trades: 47,
        winRate: 63.8,
        maxDrawdown: 3.2,
        sharpe: 1.85,
        startTime: Date.now() - 86400000 * 3,
        params: {
          lookback_period: { value: 20, hot: true, min: 5, max: 100, desc: "Number of periods for momentum calculation" },
          entry_threshold: { value: 0.02, hot: true, min: 0.001, max: 0.1, step: 0.001, desc: "Minimum momentum for entry" },
          exit_threshold: { value: 0.01, hot: true, min: 0.001, max: 0.05, step: 0.001, desc: "Momentum threshold for exit" },
          position_size: { value: 0.1, hot: true, min: 0.01, max: 1, step: 0.01, desc: "Position size as fraction of capital" },
          stop_loss: { value: 0.03, hot: false, min: 0.01, max: 0.1, step: 0.005, desc: "Stop loss percentage" },
          take_profit: { value: 0.06, hot: false, min: 0.02, max: 0.2, step: 0.01, desc: "Take profit percentage" },
        }
      },
      {
        id: "strat-002",
        name: "ETH Grid",
        type: "grid",
        symbol: "ETHUSDT",
        status: "stopped",
        capital: 5000,
        pnl: -45.20,
        pnlPercent: -0.90,
        trades: 128,
        winRate: 52.3,
        maxDrawdown: 5.8,
        sharpe: 0.42,
        startTime: Date.now() - 86400000 * 7,
        params: {
          grid_levels: { value: 10, hot: false, min: 3, max: 50, desc: "Number of grid levels" },
          grid_spacing: { value: 0.5, hot: true, min: 0.1, max: 5, step: 0.1, desc: "Spacing between grid levels (%)" },
          order_size: { value: 0.05, hot: true, min: 0.01, max: 0.5, step: 0.01, desc: "Order size per grid level" },
          upper_bound: { value: 2500, hot: false, min: 1000, max: 10000, desc: "Upper price bound" },
          lower_bound: { value: 1500, hot: false, min: 500, max: 5000, desc: "Lower price bound" },
        }
      },
      {
        id: "strat-003",
        name: "BTC Mean Reversion",
        type: "mean_reversion",
        symbol: "BTCUSDT",
        status: "paused",
        capital: 15000,
        pnl: 1245.80,
        pnlPercent: 8.31,
        trades: 23,
        winRate: 78.3,
        maxDrawdown: 2.1,
        sharpe: 2.34,
        startTime: Date.now() - 86400000 * 14,
        params: {
          ma_period: { value: 50, hot: true, min: 10, max: 200, desc: "Moving average period" },
          std_multiplier: { value: 2.0, hot: true, min: 1, max: 4, step: 0.1, desc: "Standard deviation multiplier for bands" },
          reversion_target: { value: 0.5, hot: true, min: 0.1, max: 1, step: 0.1, desc: "Target reversion level (0=band, 1=MA)" },
          position_size: { value: 0.15, hot: true, min: 0.01, max: 1, step: 0.01, desc: "Position size as fraction of capital" },
        }
      }
    ];

    // Trade history store
    let tradeHistory = [
      { id: 1, strategyId: "strat-001", strategyName: "BTC Momentum", symbol: "BTCUSDT", side: "BUY", qty: 0.005, price: 42150, pnl: null, ts: Date.now() - 3600000 },
      { id: 2, strategyId: "strat-001", strategyName: "BTC Momentum", symbol: "BTCUSDT", side: "SELL", qty: 0.005, price: 42380, pnl: 11.50, ts: Date.now() - 1800000 },
      { id: 3, strategyId: "strat-003", strategyName: "BTC Mean Reversion", symbol: "BTCUSDT", side: "BUY", qty: 0.01, price: 41800, pnl: null, ts: Date.now() - 900000 },
    ];

    let currentEditStrategy = null;

    // Render strategy cards
    function renderStrategies() {
      const grid = document.getElementById("strategyGrid");
      grid.innerHTML = "";

      for (const strat of strategies) {
        const card = document.createElement("div");
        card.className = "strategy-card";
        card.innerHTML = `
          <div class="strategy-card-header">
            <div>
              <h3 class="strategy-name">${escapeHtml(strat.name)}</h3>
              <div class="strategy-type">${escapeHtml(strat.type)} | ${escapeHtml(strat.symbol)}</div>
            </div>
            <span class="badge badge-${strat.status}">${strat.status}</span>
          </div>
          <div class="strategy-metrics">
            <div class="metric-item">
              <span class="metric-label">PnL</span>
              <span class="metric-value ${strat.pnl >= 0 ? 'positive' : 'negative'}">
                ${strat.pnl >= 0 ? '+' : ''}${strat.pnl.toFixed(2)} (${strat.pnlPercent >= 0 ? '+' : ''}${strat.pnlPercent.toFixed(2)}%)
              </span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Trades</span>
              <span class="metric-value">${strat.trades}</span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Win Rate</span>
              <span class="metric-value">${strat.winRate.toFixed(1)}%</span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Max DD</span>
              <span class="metric-value negative">-${strat.maxDrawdown.toFixed(1)}%</span>
            </div>
          </div>
          <div class="strategy-actions">
            ${strat.status === 'running'
              ? `<button class="btn-warning btn-sm" onclick="pauseStrategy('${strat.id}')">Pause</button>
                 <button class="btn-danger btn-sm" onclick="stopStrategy('${strat.id}')">Stop</button>`
              : strat.status === 'paused'
              ? `<button class="btn-success btn-sm" onclick="startStrategy('${strat.id}')">Resume</button>
                 <button class="btn-danger btn-sm" onclick="stopStrategy('${strat.id}')">Stop</button>`
              : `<button class="btn-success btn-sm" onclick="startStrategy('${strat.id}')">Start</button>`
            }
            <button class="btn-secondary btn-sm" onclick="editStrategy('${strat.id}')">Edit</button>
          </div>
        `;
        grid.appendChild(card);
      }

      // Update filter dropdown
      const filter = document.getElementById("tradeHistoryFilter");
      const currentValue = filter.value;
      filter.innerHTML = '<option value="all">All Strategies</option>';
      for (const strat of strategies) {
        const opt = document.createElement("option");
        opt.value = strat.id;
        opt.textContent = strat.name;
        filter.appendChild(opt);
      }
      filter.value = currentValue;
    }

    // Render performance summary
    function renderPerformanceSummary() {
      const running = strategies.filter(s => s.status === 'running').length;
      const totalPnl = strategies.reduce((sum, s) => sum + s.pnl, 0);
      const totalTrades = strategies.reduce((sum, s) => sum + s.trades, 0);
      const avgWinRate = strategies.length > 0
        ? strategies.reduce((sum, s) => sum + s.winRate, 0) / strategies.length
        : 0;
      const avgSharpe = strategies.length > 0
        ? strategies.reduce((sum, s) => sum + s.sharpe, 0) / strategies.length
        : 0;

      const pnlEl = document.getElementById("totalPnl");
      pnlEl.textContent = `$${totalPnl.toFixed(2)}`;
      pnlEl.className = `mono metric-value ${totalPnl >= 0 ? 'positive' : 'negative'}`;

      setText("winRate", `${avgWinRate.toFixed(1)}%`);
      setText("totalTrades", totalTrades);
      setText("activeStrategies", `${running}/${strategies.length}`);
      setText("sharpeRatio", avgSharpe.toFixed(2));
    }

    // Render trade history
    function renderTradeHistory(filterId = "all") {
      const container = document.getElementById("tradeHistoryContainer");
      const filtered = filterId === "all"
        ? tradeHistory
        : tradeHistory.filter(t => t.strategyId === filterId);

      if (filtered.length === 0) {
        container.innerHTML = '<div class="muted" style="padding: 20px; text-align: center;">No trades yet</div>';
        return;
      }

      container.innerHTML = filtered.slice().reverse().slice(0, 50).map(trade => `
        <div class="trade-row">
          <span class="trade-side ${trade.side.toLowerCase()}">${trade.side}</span>
          <div class="trade-info">
            <div class="trade-symbol">${escapeHtml(trade.symbol)}</div>
            <div class="trade-details">
              ${escapeHtml(trade.strategyName)} | ${trade.qty} @ ${trade.price.toFixed(2)} | ${formatTime(trade.ts)}
            </div>
          </div>
          ${trade.pnl !== null
            ? `<span class="trade-pnl ${trade.pnl >= 0 ? 'positive' : 'negative'}">
                ${trade.pnl >= 0 ? '+' : ''}$${trade.pnl.toFixed(2)}
               </span>`
            : '<span class="trade-pnl muted">Open</span>'
          }
        </div>
      `).join("");
    }

    // Render metrics table
    function renderMetricsTable() {
      const body = document.getElementById("metricsBody");
      body.innerHTML = "";

      for (const strat of strategies) {
        const tr = document.createElement("tr");
        const uptime = formatUptime(Date.now() - strat.startTime);
        tr.innerHTML = `
          <td><strong>${escapeHtml(strat.name)}</strong><br><span class="muted">${escapeHtml(strat.type)}</span></td>
          <td><span class="badge badge-${strat.status}">${strat.status}</span></td>
          <td class="mono ${strat.pnl >= 0 ? 'positive' : 'negative'}">${strat.pnl >= 0 ? '+' : ''}$${strat.pnl.toFixed(2)}</td>
          <td class="mono">${strat.trades}</td>
          <td class="mono">${strat.winRate.toFixed(1)}%</td>
          <td class="mono negative">-${strat.maxDrawdown.toFixed(1)}%</td>
          <td class="mono">${strat.sharpe.toFixed(2)}</td>
          <td class="mono">${uptime}</td>
        `;
        body.appendChild(tr);
      }
    }

    // Strategy actions
    function startStrategy(id) {
      const strat = strategies.find(s => s.id === id);
      if (strat) {
        strat.status = "running";
        strat.startTime = Date.now();
        renderStrategies();
        renderPerformanceSummary();
        renderMetricsTable();
        // In production, this would call: POST /api/strategies/{id}/start
        console.log(`Starting strategy: ${strat.name}`);
      }
    }

    function pauseStrategy(id) {
      const strat = strategies.find(s => s.id === id);
      if (strat) {
        strat.status = "paused";
        renderStrategies();
        renderPerformanceSummary();
        renderMetricsTable();
        // In production, this would call: POST /api/strategies/{id}/pause
        console.log(`Pausing strategy: ${strat.name}`);
      }
    }

    function stopStrategy(id) {
      const strat = strategies.find(s => s.id === id);
      if (strat) {
        strat.status = "stopped";
        renderStrategies();
        renderPerformanceSummary();
        renderMetricsTable();
        // In production, this would call: POST /api/strategies/{id}/stop
        console.log(`Stopping strategy: ${strat.name}`);
      }
    }

    function editStrategy(id) {
      const strat = strategies.find(s => s.id === id);
      if (!strat) return;

      currentEditStrategy = strat;
      document.getElementById("modalTitle").textContent = `Edit ${strat.name} Parameters`;

      const content = document.getElementById("modalContent");
      content.innerHTML = `
        <div class="param-form">
          ${Object.entries(strat.params).map(([key, param]) => `
            <div class="param-group">
              <label class="param-label">
                ${formatParamName(key)}
                ${param.hot ? '<span class="hot-badge">HOT</span>' : ''}
              </label>
              <input
                type="number"
                class="param-input"
                id="param-${key}"
                value="${param.value}"
                min="${param.min || ''}"
                max="${param.max || ''}"
                step="${param.step || 1}"
                ${!param.hot && strat.status === 'running' ? 'disabled' : ''}
              />
              <div class="param-hint">${escapeHtml(param.desc)}${!param.hot && strat.status === 'running' ? ' (Stop strategy to modify)' : ''}</div>
            </div>
          `).join("")}
        </div>
      `;

      document.getElementById("strategyModal").classList.add("active");
    }

    function saveStrategyParams() {
      if (!currentEditStrategy) return;

      const strat = currentEditStrategy;
      let hasChanges = false;

      for (const [key, param] of Object.entries(strat.params)) {
        const input = document.getElementById(`param-${key}`);
        if (input && !input.disabled) {
          const newValue = parseFloat(input.value);
          if (!isNaN(newValue) && newValue !== param.value) {
            param.value = newValue;
            hasChanges = true;
          }
        }
      }

      if (hasChanges) {
        // In production, this would call: PUT /api/strategies/{id}/params
        console.log(`Updated parameters for ${strat.name}:`, strat.params);
      }

      closeModal();
      renderStrategies();
    }

    function closeModal() {
      document.getElementById("strategyModal").classList.remove("active");
      currentEditStrategy = null;
    }

    // New strategy modal
    function openNewStrategyModal() {
      document.getElementById("newStrategyModal").classList.add("active");
    }

    function closeNewStrategyModal() {
      document.getElementById("newStrategyModal").classList.remove("active");
    }

    function createNewStrategy() {
      const name = document.getElementById("newStrategyName").value.trim();
      const type = document.getElementById("newStrategyType").value;
      const symbol = document.getElementById("newStrategySymbol").value.trim().toUpperCase();
      const capital = parseFloat(document.getElementById("newStrategyCapital").value);

      if (!name || !symbol || isNaN(capital) || capital <= 0) {
        alert("Please fill in all fields correctly");
        return;
      }

      const newStrat = {
        id: `strat-${Date.now()}`,
        name,
        type,
        symbol,
        status: "stopped",
        capital,
        pnl: 0,
        pnlPercent: 0,
        trades: 0,
        winRate: 0,
        maxDrawdown: 0,
        sharpe: 0,
        startTime: Date.now(),
        params: getDefaultParams(type)
      };

      strategies.push(newStrat);
      closeNewStrategyModal();
      renderStrategies();
      renderPerformanceSummary();
      renderMetricsTable();

      // Clear form
      document.getElementById("newStrategyName").value = "";
      document.getElementById("newStrategySymbol").value = "BTCUSDT";
      document.getElementById("newStrategyCapital").value = "10000";

      // In production, this would call: POST /api/strategies
      console.log("Created new strategy:", newStrat);
    }

    function getDefaultParams(type) {
      const defaults = {
        momentum: {
          lookback_period: { value: 20, hot: true, min: 5, max: 100, desc: "Number of periods for momentum calculation" },
          entry_threshold: { value: 0.02, hot: true, min: 0.001, max: 0.1, step: 0.001, desc: "Minimum momentum for entry" },
          position_size: { value: 0.1, hot: true, min: 0.01, max: 1, step: 0.01, desc: "Position size as fraction of capital" },
        },
        mean_reversion: {
          ma_period: { value: 50, hot: true, min: 10, max: 200, desc: "Moving average period" },
          std_multiplier: { value: 2.0, hot: true, min: 1, max: 4, step: 0.1, desc: "Standard deviation multiplier" },
          position_size: { value: 0.1, hot: true, min: 0.01, max: 1, step: 0.01, desc: "Position size as fraction of capital" },
        },
        grid: {
          grid_levels: { value: 10, hot: false, min: 3, max: 50, desc: "Number of grid levels" },
          grid_spacing: { value: 0.5, hot: true, min: 0.1, max: 5, step: 0.1, desc: "Spacing between grid levels (%)" },
          order_size: { value: 0.05, hot: true, min: 0.01, max: 0.5, step: 0.01, desc: "Order size per grid level" },
        },
        arbitrage: {
          min_spread: { value: 0.1, hot: true, min: 0.01, max: 1, step: 0.01, desc: "Minimum spread percentage" },
          position_size: { value: 0.1, hot: true, min: 0.01, max: 1, step: 0.01, desc: "Position size as fraction of capital" },
        },
        market_making: {
          spread: { value: 0.1, hot: true, min: 0.01, max: 1, step: 0.01, desc: "Bid-ask spread percentage" },
          order_size: { value: 0.01, hot: true, min: 0.001, max: 0.1, step: 0.001, desc: "Order size" },
          levels: { value: 5, hot: false, min: 1, max: 20, desc: "Number of price levels" },
        },
        custom: {
          param1: { value: 1, hot: true, min: 0, max: 100, desc: "Custom parameter 1" },
          param2: { value: 1, hot: true, min: 0, max: 100, desc: "Custom parameter 2" },
        }
      };
      return defaults[type] || defaults.custom;
    }

    // Update strategy from SSE event
    function updateStrategyFromEvent(data) {
      const strat = strategies.find(s => s.id === data.strategy_id);
      if (strat) {
        if (data.pnl !== undefined) strat.pnl = data.pnl;
        if (data.pnl_percent !== undefined) strat.pnlPercent = data.pnl_percent;
        if (data.trades !== undefined) strat.trades = data.trades;
        if (data.win_rate !== undefined) strat.winRate = data.win_rate;
        if (data.status !== undefined) strat.status = data.status;
        renderStrategies();
        renderPerformanceSummary();
        renderMetricsTable();
      }
    }

    // Update strategy metrics from market data
    function updateStrategyMetricsFromMarket(marketData) {
      // Simulate PnL updates based on market movements
      for (const strat of strategies) {
        if (strat.status === "running" && strat.symbol === marketData.symbol) {
          // Simulate small random PnL changes
          const change = (Math.random() - 0.48) * 10;
          strat.pnl += change;
          strat.pnlPercent = (strat.pnl / strat.capital) * 100;
        }
      }
      // Throttle rendering
      if (!updateStrategyMetricsFromMarket._throttle) {
        updateStrategyMetricsFromMarket._throttle = setTimeout(() => {
          renderStrategies();
          renderPerformanceSummary();
          updateStrategyMetricsFromMarket._throttle = null;
        }, 1000);
      }
    }

    // Add trade from order event
    function addStrategyTrade(data) {
      // Find matching strategy by symbol
      const strat = strategies.find(s => s.symbol === data.symbol && s.status === "running");
      if (strat && data.client_order_id && data.client_order_id.startsWith("strat-")) {
        const trade = {
          id: Date.now(),
          strategyId: strat.id,
          strategyName: strat.name,
          symbol: data.symbol,
          side: data.side || "BUY",
          qty: data.qty || 0,
          price: data.price || 0,
          pnl: data.type === "fill" ? (Math.random() - 0.4) * 50 : null,
          ts: Date.now()
        };
        tradeHistory.push(trade);
        strat.trades++;
        renderTradeHistory(document.getElementById("tradeHistoryFilter").value);
      }
    }

    // Utility functions
    function escapeHtml(str) {
      if (str == null) return "";
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function formatParamName(key) {
      return key.replace(/_/g, " ").replace(/\b\w/g, c => c.toUpperCase());
    }

    function formatTime(ts) {
      const d = new Date(ts);
      return d.toLocaleTimeString();
    }

    function formatUptime(ms) {
      const hours = Math.floor(ms / 3600000);
      const minutes = Math.floor((ms % 3600000) / 60000);
      if (hours > 24) {
        const days = Math.floor(hours / 24);
        return `${days}d ${hours % 24}h`;
      }
      return `${hours}h ${minutes}m`;
    }

    // ============================================================================
    // Event Listeners
    // ============================================================================
    document.getElementById("refresh").addEventListener("click", () => refreshMarket().catch(console.error));
    document.getElementById("reloadOrders").addEventListener("click", () => refreshOrders().catch(console.error));
    document.getElementById("reloadState").addEventListener("click", () => refreshState().catch(console.error));
    document.getElementById("reloadAccount").addEventListener("click", () => refreshAccount().catch(console.error));
    document.getElementById("submit").addEventListener("click", () => submitOrder().catch(console.error));
    document.getElementById("cancel").addEventListener("click", () => cancelOrder().catch(console.error));
    document.getElementById("execPing").addEventListener("click", () => execPing().catch(console.error));

    document.getElementById("apiBase").value = apiBase;
    document.getElementById("saveApi").addEventListener("click", () => {
      const v = document.getElementById("apiBase").value.trim().replace(/\/$/, "");
      apiBase = v;
      localStorage.setItem("veloz_api_base", apiBase);
      refreshMarket().catch(() => { });
      refreshOrders().catch(() => { });
    });

    // Strategy event listeners
    document.getElementById("addStrategy").addEventListener("click", openNewStrategyModal);
    document.getElementById("closeModal").addEventListener("click", closeModal);
    document.getElementById("cancelModal").addEventListener("click", closeModal);
    document.getElementById("saveModal").addEventListener("click", saveStrategyParams);
    document.getElementById("closeNewModal").addEventListener("click", closeNewStrategyModal);
    document.getElementById("cancelNewModal").addEventListener("click", closeNewStrategyModal);
    document.getElementById("createStrategy").addEventListener("click", createNewStrategy);

    document.getElementById("refreshPerformance").addEventListener("click", renderPerformanceSummary);
    document.getElementById("refreshTradeHistory").addEventListener("click", () => {
      renderTradeHistory(document.getElementById("tradeHistoryFilter").value);
    });
    document.getElementById("refreshMetrics").addEventListener("click", renderMetricsTable);
    document.getElementById("tradeHistoryFilter").addEventListener("change", (e) => {
      renderTradeHistory(e.target.value);
    });

    // Close modals on overlay click
    document.getElementById("strategyModal").addEventListener("click", (e) => {
      if (e.target.id === "strategyModal") closeModal();
    });
    document.getElementById("newStrategyModal").addEventListener("click", (e) => {
      if (e.target.id === "newStrategyModal") closeNewStrategyModal();
    });

    // ============================================================================
    // Initialization
    // ============================================================================
    const savedBase = localStorage.getItem("veloz_api_base");
    if (savedBase && !apiBase) {
      apiBase = savedBase;
      document.getElementById("apiBase").value = apiBase;
    }

    let sse = null;
    try {
      sse = attachSse();
    } catch {
      sse = null;
    }

    if (!sse) {
      document.getElementById("transport").textContent = "poll";
      refreshConfig().catch(() => { });
      refreshMarket().catch(() => { });
      refreshOrders().catch(() => { });
      refreshState().catch(() => { });
      refreshAccount().catch(() => { });
      setInterval(() => refreshMarket().catch(() => { }), 1000);
      setInterval(() => refreshOrders().catch(() => { }), 1500);
    } else {
      document.getElementById("transport").textContent = "sse";
      refreshConfig().catch(() => { });
      refreshOrders().catch(() => { });
      refreshState().catch(() => { });
      refreshAccount().catch(() => { });
    }

    // Initialize strategy UI
    renderStrategies();
    renderPerformanceSummary();
    renderTradeHistory();
    renderMetricsTable();

    // Simulate periodic strategy updates (for demo purposes)
    setInterval(() => {
      for (const strat of strategies) {
        if (strat.status === "running") {
          // Simulate trade activity
          if (Math.random() < 0.1) {
            strat.trades++;
            const pnlChange = (Math.random() - 0.45) * 20;
            strat.pnl += pnlChange;
            strat.pnlPercent = (strat.pnl / strat.capital) * 100;

            // Update win rate
            if (pnlChange > 0) {
              strat.winRate = Math.min(100, strat.winRate + 0.1);
            } else {
              strat.winRate = Math.max(0, strat.winRate - 0.1);
            }
          }
        }
      }
      renderStrategies();
      renderPerformanceSummary();
      renderMetricsTable();
    }, 5000);

    // ============================================================================
    // Order Book State and Functions
    // ============================================================================
    let orderbookState = {
      symbol: 'BTCUSDT',
      bids: [],
      asks: [],
      lastUpdate: null,
      connected: false,
      grouping: 0
    };

    // Generate mock order book data for demo
    function generateMockOrderBook(symbol) {
      const basePrice = symbol === 'BTCUSDT' ? 45000 :
                        symbol === 'ETHUSDT' ? 2500 : 350;
      const spread = basePrice * 0.0001; // 0.01% spread
      const midPrice = basePrice + (Math.random() - 0.5) * basePrice * 0.001;

      const bids = [];
      const asks = [];

      // Generate 15 levels each side
      for (let i = 0; i < 15; i++) {
        const bidPrice = midPrice - spread / 2 - i * spread * 0.5;
        const askPrice = midPrice + spread / 2 + i * spread * 0.5;
        const bidQty = Math.random() * 10 + 0.1;
        const askQty = Math.random() * 10 + 0.1;

        bids.push({ price: bidPrice, qty: bidQty });
        asks.push({ price: askPrice, qty: askQty });
      }

      return { symbol, bids, asks, lastUpdate: Date.now() };
    }

    // Update order book display
    function updateOrderBookDisplay() {
      const { symbol, bids, asks, lastUpdate, connected, grouping } = orderbookState;

      // Update symbol display
      document.getElementById('obSymbol').textContent = symbol || '-';

      // Calculate stats
      const bestBid = bids.length > 0 ? bids[0].price : null;
      const bestAsk = asks.length > 0 ? asks[0].price : null;
      const spread = bestBid && bestAsk ? bestAsk - bestBid : null;
      const spreadPct = spread && bestBid ? (spread / bestBid) * 100 : null;
      const midPrice = bestBid && bestAsk ? (bestBid + bestAsk) / 2 : null;
      const bidDepth = bids.reduce((sum, l) => sum + l.qty, 0);
      const askDepth = asks.reduce((sum, l) => sum + l.qty, 0);
      const totalDepth = bidDepth + askDepth;
      const imbalance = totalDepth > 0 ? (bidDepth / totalDepth) * 100 : 50;

      // Update header stats
      document.getElementById('obSpread').textContent = spread !== null ? spread.toFixed(4) : '-';
      document.getElementById('obMidPrice').textContent = midPrice !== null ? midPrice.toFixed(2) : '-';
      document.getElementById('obSpreadValue').textContent = spread !== null ? spread.toFixed(4) : '-';

      // Update market stats panel
      document.getElementById('obBestBid').textContent = bestBid !== null ? bestBid.toFixed(2) : '-';
      document.getElementById('obBestAsk').textContent = bestAsk !== null ? bestAsk.toFixed(2) : '-';
      document.getElementById('obSpreadAbs').textContent = spread !== null ? spread.toFixed(4) : '-';
      document.getElementById('obSpreadPct').textContent = spreadPct !== null ? spreadPct.toFixed(4) + '%' : '-';
      document.getElementById('obBidDepth').textContent = bidDepth.toFixed(4);
      document.getElementById('obAskDepth').textContent = askDepth.toFixed(4);

      // Update imbalance indicator
      document.getElementById('obImbalanceBar').style.width = imbalance.toFixed(1) + '%';
      document.getElementById('obImbalanceValue').textContent = imbalance.toFixed(1) + '%';

      // Update last update time
      if (lastUpdate) {
        const d = new Date(lastUpdate);
        document.getElementById('obLastUpdate').textContent = d.toLocaleTimeString();
      }

      // Update connection status
      const statusDot = document.getElementById('orderbookStatusDot');
      const statusText = document.getElementById('orderbookStatusText');
      if (connected) {
        statusDot.className = 'status-dot connected';
        statusText.textContent = 'Connected';
      } else {
        statusDot.className = 'status-dot disconnected';
        statusText.textContent = 'Mock Data';
      }

      // Calculate max depth for bar widths
      const maxBidDepth = Math.max(...bids.map(l => l.qty), 0.001);
      const maxAskDepth = Math.max(...asks.map(l => l.qty), 0.001);

      // Apply grouping if set
      let displayBids = bids;
      let displayAsks = asks;
      if (grouping > 0) {
        displayBids = groupPriceLevels(bids, grouping, 'bid');
        displayAsks = groupPriceLevels(asks, grouping, 'ask');
      }

      // Render asks (reversed so lowest ask is at bottom)
      const asksContainer = document.getElementById('orderbookAsks');
      if (displayAsks.length > 0) {
        let cumulativeAsk = 0;
        const asksWithCumulative = displayAsks.slice().reverse().map(level => {
          cumulativeAsk += level.qty;
          return { ...level, cumulative: cumulativeAsk };
        }).reverse();

        const maxCumulativeAsk = asksWithCumulative.length > 0 ? asksWithCumulative[0].cumulative : 1;

        asksContainer.innerHTML = asksWithCumulative.slice().reverse().map(level => {
          const depthPct = (level.cumulative / maxCumulativeAsk) * 100;
          return `
            <div class="orderbook-row" data-price="${level.price}">
              <div class="depth-bar ask-depth" style="width: ${depthPct.toFixed(1)}%"></div>
              <span class="level-price ask-price">${level.price.toFixed(2)}</span>
              <span class="level-qty">${level.qty.toFixed(4)}</span>
              <span class="level-total">${level.cumulative.toFixed(4)}</span>
            </div>
          `;
        }).join('');
      } else {
        asksContainer.innerHTML = '<div class="orderbook-empty">No asks</div>';
      }

      // Render bids
      const bidsContainer = document.getElementById('orderbookBids');
      if (displayBids.length > 0) {
        let cumulativeBid = 0;
        const bidsWithCumulative = displayBids.map(level => {
          cumulativeBid += level.qty;
          return { ...level, cumulative: cumulativeBid };
        });

        const maxCumulativeBid = bidsWithCumulative.length > 0 ?
          bidsWithCumulative[bidsWithCumulative.length - 1].cumulative : 1;

        bidsContainer.innerHTML = bidsWithCumulative.map(level => {
          const depthPct = (level.cumulative / maxCumulativeBid) * 100;
          return `
            <div class="orderbook-row" data-price="${level.price}">
              <div class="depth-bar bid-depth" style="width: ${depthPct.toFixed(1)}%"></div>
              <span class="level-price bid-price">${level.price.toFixed(2)}</span>
              <span class="level-qty">${level.qty.toFixed(4)}</span>
              <span class="level-total">${level.cumulative.toFixed(4)}</span>
            </div>
          `;
        }).join('');
      } else {
        bidsContainer.innerHTML = '<div class="orderbook-empty">No bids</div>';
      }
    }

    // Group price levels by tick size
    function groupPriceLevels(levels, tickSize, side) {
      if (tickSize <= 0 || levels.length === 0) return levels;

      const grouped = new Map();
      for (const level of levels) {
        const groupedPrice = side === 'bid'
          ? Math.floor(level.price / tickSize) * tickSize
          : Math.ceil(level.price / tickSize) * tickSize;

        if (grouped.has(groupedPrice)) {
          grouped.get(groupedPrice).qty += level.qty;
        } else {
          grouped.set(groupedPrice, { price: groupedPrice, qty: level.qty });
        }
      }

      const result = Array.from(grouped.values());
      if (side === 'bid') {
        result.sort((a, b) => b.price - a.price);
      } else {
        result.sort((a, b) => a.price - b.price);
      }
      return result.slice(0, 15);
    }

    // Refresh order book (fetch from API or generate mock)
    async function refreshOrderBook() {
      const symbol = document.getElementById('orderbookSymbol').value;
      orderbookState.symbol = symbol;

      try {
        // Try to fetch from API
        const resp = await fetch(`${apiBase}/api/depth?symbol=${encodeURIComponent(symbol)}`);
        if (resp.ok) {
          const data = await resp.json();
          orderbookState.bids = (data.bids || []).map(b =>
            Array.isArray(b) ? { price: parseFloat(b[0]), qty: parseFloat(b[1]) } : b
          );
          orderbookState.asks = (data.asks || []).map(a =>
            Array.isArray(a) ? { price: parseFloat(a[0]), qty: parseFloat(a[1]) } : a
          );
          orderbookState.lastUpdate = Date.now();
          orderbookState.connected = true;
        } else {
          throw new Error('API not available');
        }
      } catch (e) {
        // Fall back to mock data
        const mockData = generateMockOrderBook(symbol);
        orderbookState.bids = mockData.bids;
        orderbookState.asks = mockData.asks;
        orderbookState.lastUpdate = mockData.lastUpdate;
        orderbookState.connected = false;
      }

      updateOrderBookDisplay();
    }

    // Order book event listeners
    document.getElementById('orderbookSymbol').addEventListener('change', () => {
      refreshOrderBook().catch(console.error);
    });

    document.getElementById('refreshOrderbook').addEventListener('click', () => {
      refreshOrderBook().catch(console.error);
    });

    document.getElementById('orderbookGrouping').addEventListener('change', (e) => {
      orderbookState.grouping = parseFloat(e.target.value) || 0;
      updateOrderBookDisplay();
    });

    // Initialize order book with mock data
    const initialMock = generateMockOrderBook(orderbookState.symbol);
    orderbookState.bids = initialMock.bids;
    orderbookState.asks = initialMock.asks;
    orderbookState.lastUpdate = initialMock.lastUpdate;
    updateOrderBookDisplay();

    // Simulate order book updates for demo
    setInterval(() => {
      if (!orderbookState.connected) {
        // Only simulate if not connected to real API
        const symbol = orderbookState.symbol;
        const mockData = generateMockOrderBook(symbol);
        orderbookState.bids = mockData.bids;
        orderbookState.asks = mockData.asks;
        orderbookState.lastUpdate = mockData.lastUpdate;
        updateOrderBookDisplay();
      }
    }, 2000);

    // ============================================================================
    // Positions State and Functions
    // ============================================================================
    let positionsState = {
      positions: [],
      totalPnl: 0,
      unrealizedPnl: 0,
      realizedPnl: 0,
      notionalValue: 0,
      lastUpdate: null,
      connected: false,
      pnlHistory: []
    };

    // Generate mock positions for demo
    function generateMockPositions() {
      const symbols = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT'];
      const positions = [];

      for (const symbol of symbols) {
        if (Math.random() > 0.3) { // 70% chance of having a position
          const isLong = Math.random() > 0.4;
          const basePrice = symbol === 'BTCUSDT' ? 45000 :
                            symbol === 'ETHUSDT' ? 2500 : 350;
          const size = (Math.random() * 2 + 0.1) * (isLong ? 1 : -1);
          const avgPrice = basePrice * (1 + (Math.random() - 0.5) * 0.02);
          const currentPrice = basePrice * (1 + (Math.random() - 0.5) * 0.01);
          const unrealizedPnl = size * (currentPrice - avgPrice);
          const realizedPnl = (Math.random() - 0.3) * 500;

          positions.push({
            symbol,
            size,
            avgPrice,
            currentPrice,
            unrealizedPnl,
            realizedPnl,
            side: isLong ? 'long' : 'short'
          });
        }
      }

      return positions;
    }

    // Update positions display
    function updatePositionsDisplay() {
      const { positions, lastUpdate, connected } = positionsState;

      // Calculate totals
      let totalPnl = 0;
      let unrealizedPnl = 0;
      let realizedPnl = 0;
      let notionalValue = 0;

      for (const pos of positions) {
        const posUnrealized = pos.unrealizedPnl || 0;
        const posRealized = pos.realizedPnl || 0;
        unrealizedPnl += posUnrealized;
        realizedPnl += posRealized;
        totalPnl += posUnrealized + posRealized;
        notionalValue += Math.abs(pos.size) * (pos.currentPrice || 0);
      }

      positionsState.totalPnl = totalPnl;
      positionsState.unrealizedPnl = unrealizedPnl;
      positionsState.realizedPnl = realizedPnl;
      positionsState.notionalValue = notionalValue;

      // Update summary cards
      const totalPnlEl = document.getElementById('posTotalPnl');
      const totalPnlChangeEl = document.getElementById('posTotalPnlChange');
      const unrealizedPnlEl = document.getElementById('posUnrealizedPnl');
      const realizedPnlEl = document.getElementById('posRealizedPnl');
      const notionalEl = document.getElementById('posTotalNotional');

      const formatPnlValue = (val) => {
        const sign = val >= 0 ? '+' : '';
        return `${sign}$${val.toFixed(2)}`;
      };

      totalPnlEl.textContent = formatPnlValue(totalPnl);
      totalPnlEl.className = `pnl-card-value ${totalPnl >= 0 ? 'pnl-positive' : 'pnl-negative'}`;

      const pnlPct = notionalValue > 0 ? (totalPnl / notionalValue) * 100 : 0;
      totalPnlChangeEl.textContent = `${pnlPct >= 0 ? '+' : ''}${pnlPct.toFixed(2)}%`;
      totalPnlChangeEl.className = `pnl-card-change ${pnlPct >= 0 ? 'positive' : 'negative'}`;

      unrealizedPnlEl.textContent = formatPnlValue(unrealizedPnl);
      unrealizedPnlEl.className = `pnl-card-value ${unrealizedPnl >= 0 ? 'pnl-positive' : 'pnl-negative'}`;

      realizedPnlEl.textContent = formatPnlValue(realizedPnl);
      realizedPnlEl.className = `pnl-card-value ${realizedPnl >= 0 ? 'pnl-positive' : 'pnl-negative'}`;

      notionalEl.textContent = `$${notionalValue.toFixed(2)}`;

      // Update position count
      document.getElementById('positionCount').textContent = `${positions.length} position${positions.length !== 1 ? 's' : ''}`;

      // Update connection status
      const statusDot = document.getElementById('positionStatusDot');
      const statusText = document.getElementById('positionStatusText');
      if (connected) {
        statusDot.className = 'status-dot connected';
        statusText.textContent = 'Connected';
      } else {
        statusDot.className = 'status-dot disconnected';
        statusText.textContent = 'Mock Data';
      }

      // Update last update time
      if (lastUpdate) {
        const d = new Date(lastUpdate);
        document.getElementById('posLastUpdate').textContent = d.toLocaleTimeString();
      }

      // Render positions table
      const tbody = document.getElementById('positionsBody');
      if (positions.length === 0) {
        tbody.innerHTML = `
          <tr>
            <td colspan="9" class="positions-empty" style="text-align: center; padding: 40px;">
              No open positions
            </td>
          </tr>
        `;
      } else {
        tbody.innerHTML = positions.map(pos => {
          const sideClass = pos.size > 0 ? 'side-long' : 'side-short';
          const sideLabel = pos.size > 0 ? 'LONG' : 'SHORT';
          const totalPosP = (pos.unrealizedPnl || 0) + (pos.realizedPnl || 0);
          const pnlClass = totalPosP >= 0 ? 'pnl-positive' : 'pnl-negative';
          const unrealizedClass = (pos.unrealizedPnl || 0) >= 0 ? 'pnl-positive' : 'pnl-negative';
          const cost = Math.abs(pos.size) * pos.avgPrice;
          const pnlPctPos = cost > 0 ? (totalPosP / cost) * 100 : 0;

          return `
            <tr class="position-row" data-symbol="${escapeHtml(pos.symbol)}">
              <td class="symbol-cell">${escapeHtml(pos.symbol)}</td>
              <td class="side-cell ${sideClass}">${sideLabel}</td>
              <td class="size-cell mono">${Math.abs(pos.size).toFixed(4)}</td>
              <td class="price-cell mono">${pos.avgPrice.toFixed(2)}</td>
              <td class="price-cell mono">${(pos.currentPrice || 0).toFixed(2)}</td>
              <td class="pnl-cell mono ${unrealizedClass}">${formatPnlValue(pos.unrealizedPnl || 0)}</td>
              <td class="pnl-cell mono ${pnlClass}">${formatPnlValue(pos.realizedPnl || 0)}</td>
              <td class="pnl-cell mono ${pnlClass}">${formatPnlValue(totalPosP)}</td>
              <td class="pnl-pct-cell mono ${pnlClass}">${pnlPctPos.toFixed(2)}%</td>
            </tr>
          `;
        }).join('');
      }

      // Record PnL history
      positionsState.pnlHistory.push({
        timestamp: Date.now(),
        totalPnl,
        unrealizedPnl,
        realizedPnl
      });
      if (positionsState.pnlHistory.length > 100) {
        positionsState.pnlHistory = positionsState.pnlHistory.slice(-100);
      }
    }

    // Refresh positions (fetch from API or generate mock)
    async function refreshPositions() {
      try {
        const resp = await fetch(`${apiBase}/api/positions`);
        if (resp.ok) {
          const data = await resp.json();
          positionsState.positions = (data.positions || data || []).map(p => ({
            symbol: p.symbol,
            size: parseFloat(p.size) || 0,
            avgPrice: parseFloat(p.avg_price || p.avgPrice) || 0,
            currentPrice: parseFloat(p.current_price || p.currentPrice) || 0,
            unrealizedPnl: parseFloat(p.unrealized_pnl || p.unrealizedPnl) || 0,
            realizedPnl: parseFloat(p.realized_pnl || p.realizedPnl) || 0,
            side: (parseFloat(p.size) || 0) > 0 ? 'long' : 'short'
          }));
          positionsState.lastUpdate = Date.now();
          positionsState.connected = true;
        } else {
          throw new Error('API not available');
        }
      } catch (e) {
        // Fall back to mock data
        positionsState.positions = generateMockPositions();
        positionsState.lastUpdate = Date.now();
        positionsState.connected = false;
      }

      updatePositionsDisplay();
    }

    // Positions event listeners
    document.getElementById('refreshPositions').addEventListener('click', () => {
      refreshPositions().catch(console.error);
    });

    // Initialize positions with mock data
    positionsState.positions = generateMockPositions();
    positionsState.lastUpdate = Date.now();
    updatePositionsDisplay();

    // Simulate position updates for demo
    setInterval(() => {
      if (!positionsState.connected) {
        // Update current prices and recalculate PnL
        for (const pos of positionsState.positions) {
          const basePrice = pos.symbol === 'BTCUSDT' ? 45000 :
                            pos.symbol === 'ETHUSDT' ? 2500 : 350;
          pos.currentPrice = basePrice * (1 + (Math.random() - 0.5) * 0.005);
          pos.unrealizedPnl = pos.size * (pos.currentPrice - pos.avgPrice);
        }
        positionsState.lastUpdate = Date.now();
        updatePositionsDisplay();
      }
    }, 3000);
  </script>

  <!-- Strategy API Module Integration -->
  <!-- Load this module to enable real API calls when backend is available -->
  <!-- Enable API mode by adding ?api_mode=true to the URL -->
  <script type="module" src="js/strategy-api.js"></script>

  <!-- Strategy API Integration Script -->
  <script>
    // Wait for strategy-api.js module to load
    window.addEventListener('load', () => {
      // Check if VeloZStrategy module is available
      if (typeof window.VeloZStrategy === 'undefined') {
        console.log('Strategy API module not loaded, using mock data');
        return;
      }

      const { CONFIG, ConnectionState, StrategyManager } = window.VeloZStrategy;

      // Check if API mode is enabled
      const urlParams = new URLSearchParams(window.location.search);
      const apiModeEnabled = urlParams.get('api_mode') === 'true';

      if (!apiModeEnabled) {
        console.log('Strategy API mode disabled. Add ?api_mode=true to enable.');
        return;
      }

      console.log('Initializing Strategy API integration...');

      // Initialize the strategy manager
      const manager = new StrategyManager(apiBase);

      // Add connection state indicator
      const liveIndicator = document.querySelector('.live-indicator');
      if (liveIndicator) {
        manager.addConnectionListener((state) => {
          switch (state) {
            case ConnectionState.CONNECTED:
              liveIndicator.textContent = 'Live';
              liveIndicator.style.color = 'var(--color-success)';
              break;
            case ConnectionState.CONNECTING:
            case ConnectionState.RECONNECTING:
              liveIndicator.textContent = 'Connecting...';
              liveIndicator.style.color = 'var(--color-warning)';
              break;
            case ConnectionState.DISCONNECTED:
              liveIndicator.textContent = 'Offline';
              liveIndicator.style.color = 'var(--color-danger)';
              break;
          }
        });
      }

      // Listen for strategy updates from API
      manager.addListener((apiStrategies) => {
        // Merge API strategies with local mock data or replace entirely
        if (apiStrategies.length > 0) {
          // Convert API format to UI format
          strategies = apiStrategies.map(s => ({
            id: s.id,
            name: s.name,
            type: s.type,
            symbol: s.symbol,
            status: s.status || 'stopped',
            capital: s.capital || 10000,
            pnl: s.pnl || 0,
            pnlPercent: s.pnl_percent || 0,
            trades: s.trades || 0,
            winRate: s.win_rate || 0,
            maxDrawdown: s.max_drawdown || 0,
            sharpe: s.sharpe || 0,
            startTime: s.start_time || Date.now(),
            params: s.params || {}
          }));
          renderStrategies();
          renderPerformanceSummary();
          renderMetricsTable();
        }
      });

      // Override strategy action functions to use API
      const originalStartStrategy = window.startStrategy;
      window.startStrategy = async function(id) {
        try {
          await manager.start(id);
          // Optimistically update UI
          originalStartStrategy(id);
        } catch (e) {
          console.error('Failed to start strategy:', e);
          alert('Failed to start strategy: ' + e.message);
        }
      };

      const originalPauseStrategy = window.pauseStrategy;
      window.pauseStrategy = async function(id) {
        try {
          await manager.pause(id);
          originalPauseStrategy(id);
        } catch (e) {
          console.error('Failed to pause strategy:', e);
          alert('Failed to pause strategy: ' + e.message);
        }
      };

      const originalStopStrategy = window.stopStrategy;
      window.stopStrategy = async function(id) {
        try {
          await manager.stop(id);
          originalStopStrategy(id);
        } catch (e) {
          console.error('Failed to stop strategy:', e);
          alert('Failed to stop strategy: ' + e.message);
        }
      };

      // Override save params to use API
      const originalSaveStrategyParams = window.saveStrategyParams;
      window.saveStrategyParams = async function() {
        if (!currentEditStrategy) return;

        const strat = currentEditStrategy;
        const params = {};
        let hasChanges = false;

        for (const [key, param] of Object.entries(strat.params)) {
          const input = document.getElementById(`param-${key}`);
          if (input && !input.disabled) {
            const newValue = parseFloat(input.value);
            if (!isNaN(newValue) && newValue !== param.value) {
              params[key] = newValue;
              hasChanges = true;
            }
          }
        }

        if (hasChanges) {
          try {
            await manager.updateParams(strat.id, params);
            // Update local state
            for (const [key, value] of Object.entries(params)) {
              strat.params[key].value = value;
            }
          } catch (e) {
            console.error('Failed to update params:', e);
            alert('Failed to update parameters: ' + e.message);
            return;
          }
        }

        closeModal();
        renderStrategies();
      };

      // Override create strategy to use API
      const originalCreateNewStrategy = window.createNewStrategy;
      window.createNewStrategy = async function() {
        const name = document.getElementById("newStrategyName").value.trim();
        const type = document.getElementById("newStrategyType").value;
        const symbol = document.getElementById("newStrategySymbol").value.trim().toUpperCase();
        const capital = parseFloat(document.getElementById("newStrategyCapital").value);

        if (!name || !symbol || isNaN(capital) || capital <= 0) {
          alert("Please fill in all fields correctly");
          return;
        }

        try {
          const result = await manager.create({ name, type, symbol, capital });
          if (result) {
            // Refresh strategies from API
            await manager.loadStrategies();
          }
          closeNewStrategyModal();
          document.getElementById("newStrategyName").value = "";
          document.getElementById("newStrategySymbol").value = "BTCUSDT";
          document.getElementById("newStrategyCapital").value = "10000";
        } catch (e) {
          console.error('Failed to create strategy:', e);
          alert('Failed to create strategy: ' + e.message);
        }
      };

      // Initialize manager
      manager.init().then(() => {
        console.log('Strategy API integration initialized');
      }).catch((e) => {
        console.warn('Strategy API initialization failed:', e);
      });

      // Store manager for debugging
      window._strategyManager = manager;
    });
  </script>

  <!-- Order Book API Module Integration -->
  <!-- Load this module to enable real order book updates when backend is available -->
  <script type="module" src="js/orderbook.js"></script>

  <!-- Order Book API Integration Script -->
  <script>
    // Wait for orderbook.js module to load
    window.addEventListener('load', () => {
      // Check if VeloZOrderBook module is available
      if (typeof window.VeloZOrderBook === 'undefined') {
        console.log('Order Book API module not loaded, using inline mock data');
        return;
      }

      const { OrderBook, subscribeOrderBookUpdates, renderPriceLevel } = window.VeloZOrderBook;

      // Check if API mode is enabled
      const urlParams = new URLSearchParams(window.location.search);
      const apiModeEnabled = urlParams.get('api_mode') === 'true';

      if (!apiModeEnabled) {
        console.log('Order Book API mode disabled. Add ?api_mode=true to enable.');
        return;
      }

      console.log('Initializing Order Book API integration...');

      // Create order book instance
      const orderBook = new OrderBook({
        maxLevels: 15,
        throttleMs: 100
      });

      // Track SSE connection
      let sseConnection = null;

      // Update UI when order book changes
      orderBook.addListener((ob) => {
        // Update orderbookState from the OrderBook instance
        orderbookState.bids = ob.bids.map(l => ({ price: l.price, qty: l.qty }));
        orderbookState.asks = ob.asks.map(l => ({ price: l.price, qty: l.qty }));
        orderbookState.lastUpdate = ob.lastUpdateTime;
        orderbookState.connected = true;
        orderbookState.symbol = ob.symbol || orderbookState.symbol;

        updateOrderBookDisplay();
      });

      // Subscribe to SSE updates
      function connectOrderBookSSE() {
        const symbol = document.getElementById('orderbookSymbol').value;

        // Close existing connection
        if (sseConnection) {
          sseConnection.close();
        }

        // Update status
        const statusDot = document.getElementById('orderbookStatusDot');
        const statusText = document.getElementById('orderbookStatusText');
        statusDot.className = 'status-dot connecting';
        statusText.textContent = 'Connecting...';

        sseConnection = subscribeOrderBookUpdates(apiBase, orderBook, {
          symbol: symbol,
          onConnect: () => {
            statusDot.className = 'status-dot connected';
            statusText.textContent = 'Connected';
            orderbookState.connected = true;
          },
          onError: (e) => {
            console.error('Order book SSE error:', e);
            statusDot.className = 'status-dot disconnected';
            statusText.textContent = 'Disconnected';
            orderbookState.connected = false;
          }
        });
      }

      // Override symbol change to reconnect SSE
      const symbolSelect = document.getElementById('orderbookSymbol');
      symbolSelect.addEventListener('change', () => {
        orderBook.clear();
        connectOrderBookSSE();
      });

      // Override refresh to reconnect SSE
      const refreshBtn = document.getElementById('refreshOrderbook');
      const originalRefreshClick = refreshBtn.onclick;
      refreshBtn.addEventListener('click', () => {
        orderBook.clear();
        connectOrderBookSSE();
      });

      // Initial connection
      connectOrderBookSSE();

      // Store for debugging
      window._orderBook = orderBook;
      window._orderBookSSE = () => sseConnection;
    });
  </script>

  <!-- Positions API Module Integration -->
  <!-- Load this module to enable real position updates when backend is available -->
  <script type="module" src="js/positions.js"></script>

  <!-- Positions API Integration Script -->
  <script>
    // Wait for positions.js module to load
    window.addEventListener('load', () => {
      // Check if VeloZPositions module is available
      if (typeof window.VeloZPositions === 'undefined') {
        console.log('Positions API module not loaded, using inline mock data');
        return;
      }

      const { PositionManager, subscribePositionUpdates } = window.VeloZPositions;

      // Check if API mode is enabled
      const urlParams = new URLSearchParams(window.location.search);
      const apiModeEnabled = urlParams.get('api_mode') === 'true';

      if (!apiModeEnabled) {
        console.log('Positions API mode disabled. Add ?api_mode=true to enable.');
        return;
      }

      console.log('Initializing Positions API integration...');

      // Create position manager instance
      const positionManager = new PositionManager({
        throttleMs: 100
      });

      // Track SSE connection
      let sseConnection = null;

      // Update UI when positions change
      positionManager.addListener((pm) => {
        // Update positionsState from the PositionManager instance
        positionsState.positions = pm.getAllPositions().map(p => ({
          symbol: p.symbol,
          size: p.size,
          avgPrice: p.avgPrice,
          currentPrice: p.currentPrice,
          unrealizedPnl: p.unrealizedPnl,
          realizedPnl: p.realizedPnl,
          side: p.side
        }));
        positionsState.lastUpdate = Date.now();
        positionsState.connected = true;

        updatePositionsDisplay();
      });

      // Subscribe to SSE updates
      function connectPositionsSSE() {
        // Close existing connection
        if (sseConnection) {
          sseConnection.close();
        }

        // Update status
        const statusDot = document.getElementById('positionStatusDot');
        const statusText = document.getElementById('positionStatusText');
        statusDot.className = 'status-dot connecting';
        statusText.textContent = 'Connecting...';

        sseConnection = subscribePositionUpdates(apiBase, positionManager, {
          onConnect: () => {
            statusDot.className = 'status-dot connected';
            statusText.textContent = 'Connected';
            positionsState.connected = true;
          },
          onError: (e) => {
            console.error('Positions SSE error:', e);
            statusDot.className = 'status-dot disconnected';
            statusText.textContent = 'Disconnected';
            positionsState.connected = false;
          }
        });
      }

      // Override refresh to reconnect SSE
      const refreshBtn = document.getElementById('refreshPositions');
      refreshBtn.addEventListener('click', () => {
        positionManager.clear();
        connectPositionsSSE();
      });

      // Initial connection
      connectPositionsSSE();

      // Store for debugging
      window._positionManager = positionManager;
      window._positionsSSE = () => sseConnection;
    });
  </script>

  <!-- Backtest API Module Integration -->
  <!-- Load this module to enable real backtest results when backend is available -->
  <script type="module" src="js/backtest.js"></script>

  <!-- Backtest State and Mock Data -->
  <script>
    // ============================================================================
    // Backtest Tab State Management
    // ============================================================================
    const backtestState = {
      results: [],
      selectedId: null,
      compareIds: [],
      currentView: 'results',
      connected: false,
      lastUpdate: null
    };

    // Generate mock backtest results
    function generateMockBacktestResults() {
      const strategies = ['Momentum', 'Mean Reversion', 'Grid Trading', 'Trend Following'];
      const symbols = ['BTCUSDT', 'ETHUSDT', 'SOLUSDT'];
      const results = [];

      for (let i = 0; i < 6; i++) {
        const strategyName = strategies[i % strategies.length];
        const symbol = symbols[i % symbols.length];
        const totalReturn = (Math.random() - 0.3) * 50; // -15% to +35%
        const maxDrawdown = Math.random() * 20 + 5; // 5% to 25%
        const sharpe = (Math.random() * 2.5) - 0.5; // -0.5 to 2.0
        const winRate = Math.random() * 40 + 40; // 40% to 80%
        const totalTrades = Math.floor(Math.random() * 200) + 50;

        // Generate mock trades
        const trades = [];
        for (let t = 0; t < Math.min(totalTrades, 20); t++) {
          const side = Math.random() > 0.5 ? 'buy' : 'sell';
          const price = symbol === 'BTCUSDT' ? 45000 + (Math.random() - 0.5) * 5000 :
                        symbol === 'ETHUSDT' ? 2500 + (Math.random() - 0.5) * 500 : 350 + (Math.random() - 0.5) * 50;
          const qty = Math.random() * 0.5 + 0.01;
          const pnl = (Math.random() - 0.4) * 500;

          trades.push({
            id: `trade-${i}-${t}`,
            timestamp: Date.now() - (20 - t) * 3600000,
            symbol: symbol,
            side: side,
            price: price,
            quantity: qty,
            pnl: pnl,
            fee: price * qty * 0.001
          });
        }

        // Generate mock equity curve
        const equityCurve = [];
        let equity = 10000;
        for (let e = 0; e < 30; e++) {
          equity += (Math.random() - 0.45) * 200;
          equityCurve.push({
            timestamp: Date.now() - (30 - e) * 86400000,
            equity: equity,
            drawdown: Math.max(0, 10000 - equity) / 10000 * 100
          });
        }

        results.push({
          id: `bt-${Date.now()}-${i}`,
          strategyName: strategyName,
          symbol: symbol,
          startDate: Date.now() - 30 * 86400000,
          endDate: Date.now(),
          totalReturn: totalReturn,
          maxDrawdown: maxDrawdown,
          sharpeRatio: sharpe,
          winRate: winRate,
          totalTrades: totalTrades,
          profitFactor: 1 + Math.random(),
          avgWin: Math.random() * 200 + 50,
          avgLoss: -(Math.random() * 150 + 30),
          trades: trades,
          equityCurve: equityCurve,
          params: {
            lookback: { value: 20, min: 5, max: 100 },
            threshold: { value: 0.02, min: 0.001, max: 0.1 },
            stopLoss: { value: 0.05, min: 0.01, max: 0.2 }
          }
        });
      }

      return results;
    }

    // Render backtest result card
    function renderBacktestCard(result) {
      const isSelected = backtestState.selectedId === result.id;
      const isComparing = backtestState.compareIds.includes(result.id);
      const returnClass = result.totalReturn >= 0 ? 'positive' : 'negative';

      return `
        <div class="backtest-card ${isSelected ? 'selected' : ''} ${isComparing ? 'comparing' : ''}"
             data-id="${result.id}" onclick="selectBacktest('${result.id}')">
          <div class="backtest-card-header">
            <div class="backtest-card-title">
              <span class="strategy-name">${escapeHtml(result.strategyName)}</span>
              <span class="symbol-badge">${escapeHtml(result.symbol)}</span>
            </div>
            <div class="backtest-card-actions">
              <button class="btn-compare btn-secondary" onclick="event.stopPropagation(); toggleCompare('${result.id}')"
                      title="${isComparing ? 'Remove from comparison' : 'Add to comparison'}">
                ${isComparing ? '-' : '+'}
              </button>
            </div>
          </div>
          <div class="backtest-card-metrics">
            <div class="metric">
              <span class="metric-label">Return</span>
              <span class="metric-value ${returnClass}">${result.totalReturn >= 0 ? '+' : ''}${result.totalReturn.toFixed(2)}%</span>
            </div>
            <div class="metric">
              <span class="metric-label">Max DD</span>
              <span class="metric-value negative">-${result.maxDrawdown.toFixed(2)}%</span>
            </div>
            <div class="metric">
              <span class="metric-label">Sharpe</span>
              <span class="metric-value">${result.sharpeRatio.toFixed(2)}</span>
            </div>
            <div class="metric">
              <span class="metric-label">Win Rate</span>
              <span class="metric-value">${result.winRate.toFixed(1)}%</span>
            </div>
          </div>
          <div class="backtest-card-footer">
            <span>${result.totalTrades} trades</span>
            <span>${new Date(result.endDate).toLocaleDateString()}</span>
          </div>
        </div>
      `;
    }

    // Render backtest results list
    function renderBacktestResultsList() {
      const container = document.getElementById('backtestResultsList');
      if (backtestState.results.length === 0) {
        container.innerHTML = `
          <div class="backtest-empty">
            <p>No backtest results available</p>
            <p>Run a backtest to see results here</p>
          </div>
        `;
        return;
      }

      container.innerHTML = backtestState.results.map(r => renderBacktestCard(r)).join('');
    }

    // Render metrics panel for selected backtest
    function renderBacktestMetrics() {
      const container = document.getElementById('backtestMetricsPanel');
      const result = backtestState.results.find(r => r.id === backtestState.selectedId);

      if (!result) {
        container.innerHTML = '<div class="metrics-panel-empty">Select a backtest result to view detailed metrics</div>';
        return;
      }

      const returnClass = result.totalReturn >= 0 ? 'positive' : 'negative';

      container.innerHTML = `
        <div class="metrics-section">
          <h3>Performance Metrics</h3>
          <div class="metrics-grid">
            <div class="metric-item">
              <span class="metric-label">Total Return</span>
              <span class="metric-value ${returnClass}">${result.totalReturn >= 0 ? '+' : ''}${result.totalReturn.toFixed(2)}%</span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Max Drawdown</span>
              <span class="metric-value negative">-${result.maxDrawdown.toFixed(2)}%</span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Sharpe Ratio</span>
              <span class="metric-value">${result.sharpeRatio.toFixed(2)}</span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Profit Factor</span>
              <span class="metric-value">${(result.profitFactor || 1).toFixed(2)}</span>
            </div>
          </div>
        </div>
        <div class="metrics-section">
          <h3>Trade Statistics</h3>
          <div class="metrics-grid">
            <div class="metric-item">
              <span class="metric-label">Total Trades</span>
              <span class="metric-value">${result.totalTrades}</span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Win Rate</span>
              <span class="metric-value">${result.winRate.toFixed(1)}%</span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Avg Win</span>
              <span class="metric-value positive">+$${(result.avgWin || 0).toFixed(2)}</span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Avg Loss</span>
              <span class="metric-value negative">$${(result.avgLoss || 0).toFixed(2)}</span>
            </div>
          </div>
        </div>
        <div class="metrics-section">
          <h3>Period</h3>
          <div class="metrics-grid">
            <div class="metric-item">
              <span class="metric-label">Start Date</span>
              <span class="metric-value">${new Date(result.startDate).toLocaleDateString()}</span>
            </div>
            <div class="metric-item">
              <span class="metric-label">End Date</span>
              <span class="metric-value">${new Date(result.endDate).toLocaleDateString()}</span>
            </div>
          </div>
        </div>
      `;
    }

    // Render trades table for selected backtest
    function renderBacktestTrades() {
      const container = document.getElementById('backtestTradesContainer');
      const result = backtestState.results.find(r => r.id === backtestState.selectedId);

      if (!result || !result.trades || result.trades.length === 0) {
        container.innerHTML = '<div class="trades-empty">Select a backtest result to view trade history</div>';
        return;
      }

      const tradesHtml = result.trades.map(trade => {
        const pnlClass = trade.pnl >= 0 ? 'positive' : 'negative';
        const sideClass = trade.side === 'buy' ? 'side-buy' : 'side-sell';

        return `
          <tr class="trade-row">
            <td>${new Date(trade.timestamp).toLocaleString()}</td>
            <td>${escapeHtml(trade.symbol)}</td>
            <td class="${sideClass}">${trade.side.toUpperCase()}</td>
            <td class="mono">${trade.price.toFixed(2)}</td>
            <td class="mono">${trade.quantity.toFixed(4)}</td>
            <td class="mono ${pnlClass}">${trade.pnl >= 0 ? '+' : ''}$${trade.pnl.toFixed(2)}</td>
            <td class="mono">$${(trade.fee || 0).toFixed(4)}</td>
          </tr>
        `;
      }).join('');

      container.innerHTML = `
        <table class="trades-table">
          <thead>
            <tr>
              <th>Time</th>
              <th>Symbol</th>
              <th>Side</th>
              <th>Price</th>
              <th>Quantity</th>
              <th>PnL</th>
              <th>Fee</th>
            </tr>
          </thead>
          <tbody>${tradesHtml}</tbody>
        </table>
        <div class="trades-pagination">
          <span>Showing ${result.trades.length} of ${result.totalTrades} trades</span>
        </div>
      `;
    }

    // Render comparison table
    function renderBacktestComparison() {
      const container = document.getElementById('backtestCompareContainer');

      if (backtestState.compareIds.length < 2) {
        container.innerHTML = '<div class="comparison-empty">Select at least 2 backtest results to compare</div>';
        return;
      }

      const compareResults = backtestState.compareIds
        .map(id => backtestState.results.find(r => r.id === id))
        .filter(Boolean);

      if (compareResults.length < 2) {
        container.innerHTML = '<div class="comparison-empty">Select at least 2 backtest results to compare</div>';
        return;
      }

      const headers = compareResults.map(r => `<th>${escapeHtml(r.strategyName)}<br><small>${escapeHtml(r.symbol)}</small></th>`).join('');

      const metrics = [
        { label: 'Total Return', key: 'totalReturn', format: v => `${v >= 0 ? '+' : ''}${v.toFixed(2)}%`, colorize: true },
        { label: 'Max Drawdown', key: 'maxDrawdown', format: v => `-${v.toFixed(2)}%`, colorize: false },
        { label: 'Sharpe Ratio', key: 'sharpeRatio', format: v => v.toFixed(2), colorize: false },
        { label: 'Win Rate', key: 'winRate', format: v => `${v.toFixed(1)}%`, colorize: false },
        { label: 'Total Trades', key: 'totalTrades', format: v => v.toString(), colorize: false },
        { label: 'Profit Factor', key: 'profitFactor', format: v => (v || 1).toFixed(2), colorize: false }
      ];

      const rows = metrics.map(m => {
        const cells = compareResults.map(r => {
          const value = r[m.key];
          const className = m.colorize ? (value >= 0 ? 'positive' : 'negative') : '';
          return `<td class="${className}">${m.format(value)}</td>`;
        }).join('');
        return `<tr><td class="row-label">${m.label}</td>${cells}</tr>`;
      }).join('');

      container.innerHTML = `
        <table class="comparison-table">
          <thead>
            <tr><th>Metric</th>${headers}</tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      `;
    }

    // Select a backtest result
    function selectBacktest(id) {
      backtestState.selectedId = id;
      renderBacktestResultsList();
      renderBacktestMetrics();
      renderBacktestTrades();

      // Update equity curve selector
      const select = document.getElementById('equityCurveSelect');
      select.value = id;
    }

    // Toggle comparison selection
    function toggleCompare(id) {
      const index = backtestState.compareIds.indexOf(id);
      if (index >= 0) {
        backtestState.compareIds.splice(index, 1);
      } else if (backtestState.compareIds.length < 4) {
        backtestState.compareIds.push(id);
      }
      renderBacktestResultsList();
      renderBacktestComparison();
    }

    // Switch backtest view
    function switchBacktestView(view) {
      backtestState.currentView = view;

      // Update tab buttons
      document.querySelectorAll('.backtest-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.backtestView === view);
      });

      // Update view visibility
      document.getElementById('backtestResultsView').style.display = view === 'results' ? 'block' : 'none';
      document.getElementById('backtestMetricsView').style.display = view === 'metrics' ? 'block' : 'none';
      document.getElementById('backtestTradesView').style.display = view === 'trades' ? 'block' : 'none';
      document.getElementById('backtestCompareView').style.display = view === 'compare' ? 'block' : 'none';
    }

    // Refresh backtest results
    async function refreshBacktestResults() {
      try {
        const resp = await fetch(`${apiBase}/api/backtest/results`);
        if (resp.ok) {
          const data = await resp.json();
          backtestState.results = (data.results || data || []).map(r => ({
            id: r.id || `bt-${Date.now()}`,
            strategyName: r.strategy_name || r.strategyName || '',
            symbol: r.symbol || '',
            startDate: r.start_date || r.startDate || Date.now(),
            endDate: r.end_date || r.endDate || Date.now(),
            totalReturn: parseFloat(r.total_return || r.totalReturn) || 0,
            maxDrawdown: parseFloat(r.max_drawdown || r.maxDrawdown) || 0,
            sharpeRatio: parseFloat(r.sharpe_ratio || r.sharpeRatio) || 0,
            winRate: parseFloat(r.win_rate || r.winRate) || 0,
            totalTrades: parseInt(r.total_trades || r.totalTrades) || 0,
            profitFactor: parseFloat(r.profit_factor || r.profitFactor) || 1,
            avgWin: parseFloat(r.avg_win || r.avgWin) || 0,
            avgLoss: parseFloat(r.avg_loss || r.avgLoss) || 0,
            trades: r.trades || [],
            equityCurve: r.equity_curve || r.equityCurve || [],
            params: r.params || {}
          }));
          backtestState.connected = true;
        } else {
          throw new Error('API not available');
        }
      } catch (e) {
        // Fall back to mock data
        backtestState.results = generateMockBacktestResults();
        backtestState.connected = false;
      }

      backtestState.lastUpdate = Date.now();
      renderBacktestResultsList();
      updateEquityCurveSelect();
    }

    // Update equity curve select options
    function updateEquityCurveSelect() {
      const select = document.getElementById('equityCurveSelect');
      select.innerHTML = '<option value="">Select a backtest...</option>' +
        backtestState.results.map(r =>
          `<option value="${r.id}">${escapeHtml(r.strategyName)} - ${escapeHtml(r.symbol)}</option>`
        ).join('');
    }

    // Backtest tab event listeners
    document.querySelectorAll('.backtest-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        switchBacktestView(tab.dataset.backtestView);
      });
    });

    document.getElementById('refreshBacktests').addEventListener('click', () => {
      refreshBacktestResults().catch(console.error);
    });

    document.getElementById('runBacktest').addEventListener('click', () => {
      alert('Backtest configuration dialog coming soon!');
    });

    document.getElementById('equityCurveSelect').addEventListener('change', (e) => {
      if (e.target.value) {
        selectBacktest(e.target.value);
      }
    });

    // Initialize backtest with mock data
    backtestState.results = generateMockBacktestResults();
    backtestState.lastUpdate = Date.now();
    renderBacktestResultsList();
    updateEquityCurveSelect();
  </script>

  <!-- Backtest API Integration Script -->
  <script>
    // Wait for backtest.js module to load
    window.addEventListener('load', () => {
      // Check if VeloZBacktest module is available
      if (typeof window.VeloZBacktest === 'undefined') {
        console.log('Backtest API module not loaded, using inline mock data');
        return;
      }

      const { BacktestManager, fetchBacktestResults } = window.VeloZBacktest;

      // Check if API mode is enabled
      const urlParams = new URLSearchParams(window.location.search);
      const apiModeEnabled = urlParams.get('api_mode') === 'true';

      if (!apiModeEnabled) {
        console.log('Backtest API mode disabled. Add ?api_mode=true to enable.');
        return;
      }

      console.log('Initializing Backtest API integration...');

      // Create backtest manager instance
      const backtestManager = new BacktestManager();

      // Update UI when backtest results change
      backtestManager.addListener((manager) => {
        backtestState.results = manager.results.map(r => ({
          id: r.id,
          strategyName: r.strategyName,
          symbol: r.symbol,
          startDate: r.startDate,
          endDate: r.endDate,
          totalReturn: r.totalReturn,
          maxDrawdown: r.maxDrawdown,
          sharpeRatio: r.sharpeRatio,
          winRate: r.winRate,
          totalTrades: r.totalTrades,
          profitFactor: r.profitFactor,
          avgWin: r.avgWin,
          avgLoss: r.avgLoss,
          trades: r.trades,
          equityCurve: r.equityCurve,
          params: r.params
        }));
        backtestState.selectedId = manager.selectedId;
        backtestState.compareIds = [...manager.compareIds];
        backtestState.connected = true;
        backtestState.lastUpdate = Date.now();

        renderBacktestResultsList();
        renderBacktestMetrics();
        renderBacktestTrades();
        renderBacktestComparison();
        updateEquityCurveSelect();
      });

      // Override refresh to use API
      const originalRefresh = refreshBacktestResults;
      window.refreshBacktestResults = async function() {
        try {
          const results = await fetchBacktestResults(apiBase);
          for (const r of results) {
            backtestManager.addResult(r);
          }
          backtestState.connected = true;
        } catch (e) {
          console.warn('Failed to fetch backtest results from API:', e);
          // Fall back to original mock behavior
          await originalRefresh();
        }
      };

      // Initial fetch
      refreshBacktestResults().catch(console.error);

      // Store for debugging
      window._backtestManager = backtestManager;
    });
  </script>
</body>

</html>
