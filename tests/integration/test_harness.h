/**
 * @file test_harness.h
 * @brief Integration test harness with mock components for VeloZ engine testing
 *
 * This file provides:
 * - MockMarketDataManager: Simulates market data injection
 * - MockStrategyRuntime: Captures strategy signals
 * - MockOMS: Captures order requests and simulates fills
 * - IntegrationTestHarness: Wires components together like EngineApp
 */

#pragma once

#include "veloz/common/types.h"
#include "veloz/exec/order_api.h"
#include "veloz/market/market_event.h"
#include "veloz/oms/order_record.h"
#include "veloz/oms/position.h"
#include "veloz/strategy/strategy.h"

#include <chrono>
#include <kj/async-io.h>
#include <kj/common.h>
#include <kj/function.h>
#include <kj/memory.h>
#include <kj/mutex.h>
#include <kj/string.h>
#include <kj/vector.h>

namespace veloz::test {

// ============================================================================
// Mock Market Data Manager
// ============================================================================

/**
 * @brief Mock market data manager for testing
 *
 * Allows injection of market events into the system and tracks
 * subscriptions for verification.
 */
class MockMarketDataManager {
public:
  using EventCallback = kj::Function<void(const market::MarketEvent&)>;

  MockMarketDataManager() = default;
  KJ_DISALLOW_COPY_AND_MOVE(MockMarketDataManager);

  /**
   * @brief Set callback for market events
   */
  void set_event_callback(EventCallback callback) {
    auto lock = state_.lockExclusive();
    lock->event_callback = kj::mv(callback);
  }

  /**
   * @brief Inject a market event into the system
   *
   * This simulates receiving a market event from an exchange.
   * The event is dispatched to the registered callback.
   */
  void inject_event(const market::MarketEvent& event) {
    auto lock = state_.lockExclusive();
    lock->injected_events.add(clone_event(event));
    KJ_IF_SOME(cb, lock->event_callback) {
      cb(event);
    }
  }

  /**
   * @brief Subscribe to a symbol (for tracking)
   */
  void subscribe(const common::SymbolId& symbol, market::MarketEventType type) {
    auto lock = state_.lockExclusive();
    SubscriptionRecord record;
    record.symbol = kj::heapString(symbol.value);
    record.type = type;
    record.subscribed = true;
    lock->subscriptions.add(kj::mv(record));
  }

  /**
   * @brief Unsubscribe from a symbol
   */
  void unsubscribe(const common::SymbolId& symbol, market::MarketEventType type) {
    auto lock = state_.lockExclusive();
    for (auto& sub : lock->subscriptions) {
      if (sub.symbol == symbol.value && sub.type == type) {
        sub.subscribed = false;
        break;
      }
    }
  }

  // Query methods
  [[nodiscard]] size_t injected_event_count() const {
    return state_.lockShared()->injected_events.size();
  }

  [[nodiscard]] size_t subscription_count() const {
    auto lock = state_.lockShared();
    size_t count = 0;
    for (const auto& sub : lock->subscriptions) {
      if (sub.subscribed) {
        count++;
      }
    }
    return count;
  }

  [[nodiscard]] bool is_subscribed(const common::SymbolId& symbol,
                                   market::MarketEventType type) const {
    auto lock = state_.lockShared();
    for (const auto& sub : lock->subscriptions) {
      if (sub.symbol == symbol.value && sub.type == type && sub.subscribed) {
        return true;
      }
    }
    return false;
  }

  void clear() {
    auto lock = state_.lockExclusive();
    lock->injected_events.clear();
    lock->subscriptions.clear();
  }

private:
  struct SubscriptionRecord {
    kj::String symbol;
    market::MarketEventType type;
    bool subscribed{false};
  };

  struct State {
    kj::Vector<market::MarketEvent> injected_events;
    kj::Vector<SubscriptionRecord> subscriptions;
    kj::Maybe<EventCallback> event_callback;
  };

  kj::MutexGuarded<State> state_;

  // Helper to clone a market event
  static market::MarketEvent clone_event(const market::MarketEvent& event) {
    market::MarketEvent cloned;
    cloned.type = event.type;
    cloned.venue = event.venue;
    cloned.market = event.market;
    cloned.symbol = common::SymbolId(event.symbol.value);
    cloned.ts_exchange_ns = event.ts_exchange_ns;
    cloned.ts_recv_ns = event.ts_recv_ns;
    cloned.ts_pub_ns = event.ts_pub_ns;
    // Note: data variant is not cloned for simplicity
    return cloned;
  }
};

// ============================================================================
// Mock Strategy Runtime
// ============================================================================

/**
 * @brief Mock strategy runtime for testing
 *
 * Captures signals generated by strategies and allows verification
 * of signal routing.
 */
class MockStrategyRuntime {
public:
  using SignalCallback = kj::Function<void(const kj::Vector<exec::PlaceOrderRequest>&)>;

  MockStrategyRuntime() = default;
  KJ_DISALLOW_COPY_AND_MOVE(MockStrategyRuntime);

  /**
   * @brief Set callback for signals (routes to OMS)
   */
  void set_signal_callback(SignalCallback callback) {
    auto lock = state_.lockExclusive();
    lock->signal_callback = kj::mv(callback);
  }

  /**
   * @brief Process a market event (dispatches to strategies)
   */
  void on_market_event(const market::MarketEvent& event) {
    auto lock = state_.lockExclusive();
    lock->events_received++;

    // Generate mock signals based on event type
    if (event.type == market::MarketEventType::Trade && lock->auto_generate_signals) {
      kj::Vector<exec::PlaceOrderRequest> signals;
      exec::PlaceOrderRequest order;
      order.client_order_id = kj::str("mock_order_", lock->signals_generated++);
      order.symbol = common::SymbolId(event.symbol.value);
      order.side = exec::OrderSide::Buy;
      order.type = exec::OrderType::Market;
      order.tif = exec::TimeInForce::IOC;
      order.qty = 0.001;
      signals.add(kj::mv(order));

      KJ_IF_SOME(cb, lock->signal_callback) {
        cb(signals);
      }
      lock->captured_signals.add(kj::mv(signals));
    }
  }

  /**
   * @brief Enable/disable automatic signal generation
   */
  void set_auto_generate_signals(bool enable) {
    state_.lockExclusive()->auto_generate_signals = enable;
  }

  /**
   * @brief Manually inject signals (for testing signal routing)
   */
  void inject_signals(kj::Vector<exec::PlaceOrderRequest> signals) {
    auto lock = state_.lockExclusive();
    KJ_IF_SOME(cb, lock->signal_callback) {
      cb(signals);
    }
    lock->captured_signals.add(kj::mv(signals));
  }

  // Query methods
  [[nodiscard]] size_t events_received() const {
    return state_.lockShared()->events_received;
  }

  [[nodiscard]] size_t signals_generated() const {
    return state_.lockShared()->signals_generated;
  }

  [[nodiscard]] size_t captured_signal_batches() const {
    return state_.lockShared()->captured_signals.size();
  }

  void clear() {
    auto lock = state_.lockExclusive();
    lock->events_received = 0;
    lock->signals_generated = 0;
    lock->captured_signals.clear();
  }

private:
  struct State {
    size_t events_received{0};
    size_t signals_generated{0};
    bool auto_generate_signals{false};
    kj::Vector<kj::Vector<exec::PlaceOrderRequest>> captured_signals;
    kj::Maybe<SignalCallback> signal_callback;
  };

  kj::MutexGuarded<State> state_;
};

// ============================================================================
// Mock OMS (Order Management System)
// ============================================================================

/**
 * @brief Mock OMS for testing
 *
 * Captures order requests and simulates fills for testing
 * the order flow.
 */
class MockOMS {
public:
  using FillCallback = kj::Function<void(const exec::ExecutionReport&)>;

  MockOMS() = default;
  KJ_DISALLOW_COPY_AND_MOVE(MockOMS);

  /**
   * @brief Set callback for fill reports
   */
  void set_fill_callback(FillCallback callback) {
    auto lock = state_.lockExclusive();
    lock->fill_callback = kj::mv(callback);
  }

  /**
   * @brief Submit an order (captures and optionally auto-fills)
   */
  void submit_order(const exec::PlaceOrderRequest& request) {
    auto lock = state_.lockExclusive();

    // Capture the order
    CapturedOrder captured;
    captured.client_order_id = kj::heapString(request.client_order_id);
    captured.symbol = kj::heapString(request.symbol.value);
    captured.side = request.side;
    captured.type = request.type;
    captured.qty = request.qty;
    KJ_IF_SOME(price, request.price) {
      captured.price = price;
    }
    captured.status = exec::OrderStatus::New;
    lock->captured_orders.add(kj::mv(captured));

    // Auto-fill if enabled
    if (lock->auto_fill) {
      exec::ExecutionReport report;
      report.client_order_id = kj::heapString(request.client_order_id);
      report.symbol = common::SymbolId(request.symbol.value);
      report.status = exec::OrderStatus::Filled;
      report.last_fill_qty = request.qty;
      report.last_fill_price = lock->fill_price;
      report.ts_exchange_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(
                                  std::chrono::system_clock::now().time_since_epoch())
                                  .count();

      lock->fill_reports.add(clone_report(report));

      KJ_IF_SOME(cb, lock->fill_callback) {
        cb(report);
      }
    }
  }

  /**
   * @brief Submit multiple orders
   */
  void submit_orders(const kj::Vector<exec::PlaceOrderRequest>& orders) {
    for (const auto& order : orders) {
      submit_order(order);
    }
  }

  /**
   * @brief Enable/disable automatic fills
   */
  void set_auto_fill(bool enable, double price = 50000.0) {
    auto lock = state_.lockExclusive();
    lock->auto_fill = enable;
    lock->fill_price = price;
  }

  /**
   * @brief Manually inject a fill report
   */
  void inject_fill(const exec::ExecutionReport& report) {
    auto lock = state_.lockExclusive();
    lock->fill_reports.add(clone_report(report));
    KJ_IF_SOME(cb, lock->fill_callback) {
      cb(report);
    }
  }

  // Query methods
  [[nodiscard]] size_t order_count() const {
    return state_.lockShared()->captured_orders.size();
  }

  [[nodiscard]] size_t fill_count() const {
    return state_.lockShared()->fill_reports.size();
  }

  [[nodiscard]] bool has_order(kj::StringPtr client_order_id) const {
    auto lock = state_.lockShared();
    for (const auto& order : lock->captured_orders) {
      if (order.client_order_id == client_order_id) {
        return true;
      }
    }
    return false;
  }

  [[nodiscard]] kj::Maybe<exec::OrderSide> get_order_side(kj::StringPtr client_order_id) const {
    auto lock = state_.lockShared();
    for (const auto& order : lock->captured_orders) {
      if (order.client_order_id == client_order_id) {
        return order.side;
      }
    }
    return kj::none;
  }

  void clear() {
    auto lock = state_.lockExclusive();
    lock->captured_orders.clear();
    lock->fill_reports.clear();
  }

private:
  struct CapturedOrder {
    kj::String client_order_id;
    kj::String symbol;
    exec::OrderSide side;
    exec::OrderType type;
    double qty{0.0};
    double price{0.0};
    exec::OrderStatus status;
  };

  struct State {
    kj::Vector<CapturedOrder> captured_orders;
    kj::Vector<exec::ExecutionReport> fill_reports;
    bool auto_fill{false};
    double fill_price{50000.0};
    kj::Maybe<FillCallback> fill_callback;
  };

  kj::MutexGuarded<State> state_;

  // Helper to clone an execution report
  static exec::ExecutionReport clone_report(const exec::ExecutionReport& report) {
    exec::ExecutionReport cloned;
    cloned.client_order_id = kj::heapString(report.client_order_id);
    cloned.venue_order_id = kj::heapString(report.venue_order_id);
    cloned.symbol = common::SymbolId(report.symbol.value);
    cloned.status = report.status;
    cloned.last_fill_qty = report.last_fill_qty;
    cloned.last_fill_price = report.last_fill_price;
    cloned.ts_exchange_ns = report.ts_exchange_ns;
    cloned.ts_recv_ns = report.ts_recv_ns;
    return cloned;
  }
};

// ============================================================================
// Integration Test Harness
// ============================================================================

/**
 * @brief Integration test harness that wires components together
 *
 * This harness mimics the wiring in EngineApp but uses mock components
 * for testing. It provides:
 * - Event injection via MockMarketDataManager
 * - Signal capture via MockStrategyRuntime
 * - Order capture via MockOMS
 * - Position tracking
 */
class IntegrationTestHarness {
public:
  IntegrationTestHarness()
      : market_data_(kj::heap<MockMarketDataManager>()),
        strategy_runtime_(kj::heap<MockStrategyRuntime>()),
        oms_(kj::heap<MockOMS>()),
        position_store_(kj::heap<oms::OrderStore>()) {
    wire_components();
  }

  KJ_DISALLOW_COPY_AND_MOVE(IntegrationTestHarness);

  /**
   * @brief Get market data manager for event injection
   */
  MockMarketDataManager& market_data() {
    return *market_data_;
  }

  /**
   * @brief Get strategy runtime for signal verification
   */
  MockStrategyRuntime& strategy_runtime() {
    return *strategy_runtime_;
  }

  /**
   * @brief Get OMS for order verification
   */
  MockOMS& oms() {
    return *oms_;
  }

  /**
   * @brief Get order store for position tracking
   */
  oms::OrderStore& order_store() {
    return *position_store_;
  }

  /**
   * @brief Inject a market event and process through the full pipeline
   *
   * Event flow: MarketData -> StrategyRuntime -> OMS
   */
  void inject_and_process(const market::MarketEvent& event) {
    market_data_->inject_event(event);
  }

  /**
   * @brief Enable automatic signal generation and order filling
   */
  void enable_auto_flow() {
    strategy_runtime_->set_auto_generate_signals(true);
    oms_->set_auto_fill(true);
  }

  /**
   * @brief Disable automatic signal generation and order filling
   */
  void disable_auto_flow() {
    strategy_runtime_->set_auto_generate_signals(false);
    oms_->set_auto_fill(false);
  }

  /**
   * @brief Clear all captured data
   */
  void clear() {
    market_data_->clear();
    strategy_runtime_->clear();
    oms_->clear();
    position_store_->clear();
  }

  // Convenience query methods
  [[nodiscard]] size_t events_injected() const {
    return market_data_->injected_event_count();
  }

  [[nodiscard]] size_t events_processed() const {
    return strategy_runtime_->events_received();
  }

  [[nodiscard]] size_t signals_generated() const {
    return strategy_runtime_->signals_generated();
  }

  [[nodiscard]] size_t orders_submitted() const {
    return oms_->order_count();
  }

  [[nodiscard]] size_t fills_received() const {
    return oms_->fill_count();
  }

private:
  kj::Own<MockMarketDataManager> market_data_;
  kj::Own<MockStrategyRuntime> strategy_runtime_;
  kj::Own<MockOMS> oms_;
  kj::Own<oms::OrderStore> position_store_;

  /**
   * @brief Wire components together (same pattern as EngineApp)
   */
  void wire_components() {
    // MarketData -> StrategyRuntime
    market_data_->set_event_callback(
        [this](const market::MarketEvent& event) { strategy_runtime_->on_market_event(event); });

    // StrategyRuntime -> OMS
    strategy_runtime_->set_signal_callback(
        [this](const kj::Vector<exec::PlaceOrderRequest>& signals) {
          oms_->submit_orders(signals);
        });

    // OMS -> PositionStore (via fill callback)
    oms_->set_fill_callback([this](const exec::ExecutionReport& report) {
      position_store_->apply_execution_report(report);
    });
  }
};

// ============================================================================
// Test Event Generators
// ============================================================================

/**
 * @brief Generate a trade event for testing
 */
inline market::MarketEvent make_trade_event(kj::StringPtr symbol, double price, double qty) {
  market::MarketEvent event;
  event.type = market::MarketEventType::Trade;
  event.venue = common::Venue::Binance;
  event.market = common::MarketKind::Spot;
  event.symbol = common::SymbolId(symbol);

  auto ts = std::chrono::duration_cast<std::chrono::nanoseconds>(
                std::chrono::system_clock::now().time_since_epoch())
                .count();
  event.ts_exchange_ns = ts - 1000000;
  event.ts_recv_ns = ts - 500000;
  event.ts_pub_ns = ts;

  market::TradeData trade;
  trade.price = price;
  trade.qty = qty;
  trade.is_buyer_maker = false;
  trade.trade_id = 1;
  event.data = trade;

  return event;
}

/**
 * @brief Generate a book top event for testing
 */
inline market::MarketEvent make_book_top_event(kj::StringPtr symbol, double bid_price,
                                                double bid_qty, double ask_price, double ask_qty) {
  market::MarketEvent event;
  event.type = market::MarketEventType::BookTop;
  event.venue = common::Venue::Binance;
  event.market = common::MarketKind::Spot;
  event.symbol = common::SymbolId(symbol);

  auto ts = std::chrono::duration_cast<std::chrono::nanoseconds>(
                std::chrono::system_clock::now().time_since_epoch())
                .count();
  event.ts_exchange_ns = ts - 1000000;
  event.ts_recv_ns = ts - 500000;
  event.ts_pub_ns = ts;

  market::BookData book;
  book.bids.add(market::BookLevel{bid_price, bid_qty});
  book.asks.add(market::BookLevel{ask_price, ask_qty});
  book.sequence = 1;
  book.is_snapshot = false;
  event.data = kj::mv(book);

  return event;
}

/**
 * @brief Generate a kline event for testing
 */
inline market::MarketEvent make_kline_event(kj::StringPtr symbol, double open, double high,
                                             double low, double close, double volume) {
  market::MarketEvent event;
  event.type = market::MarketEventType::Kline;
  event.venue = common::Venue::Binance;
  event.market = common::MarketKind::Spot;
  event.symbol = common::SymbolId(symbol);

  auto ts = std::chrono::duration_cast<std::chrono::nanoseconds>(
                std::chrono::system_clock::now().time_since_epoch())
                .count();
  event.ts_exchange_ns = ts - 1000000;
  event.ts_recv_ns = ts - 500000;
  event.ts_pub_ns = ts;

  market::KlineData kline;
  kline.open = open;
  kline.high = high;
  kline.low = low;
  kline.close = close;
  kline.volume = volume;
  kline.start_time = std::chrono::duration_cast<std::chrono::milliseconds>(
                         std::chrono::system_clock::now().time_since_epoch())
                         .count() -
                     60000;
  kline.close_time = kline.start_time + 60000;
  event.data = kline;

  return event;
}

} // namespace veloz::test
